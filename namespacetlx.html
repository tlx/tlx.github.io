<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>tlx: tlx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tlx
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacetlx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tlx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetlx_1_1detail"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1AllocatorBase.html">AllocatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CmdlineParser.html">CmdlineParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line parser which automatically fills variables and prints nice usage messages.  <a href="classtlx_1_1CmdlineParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtrDefaultDeleter.html">CountingPtrDefaultDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default deleter for <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer.">CountingPtr</a>  <a href="classtlx_1_1CountingPtrDefaultDeleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance smart pointer used as a wrapping reference counting pointer.  <a href="classtlx_1_1CountingPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides reference counting abilities for use with <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer.">CountingPtr</a>.  <a href="classtlx_1_1ReferenceCounter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html">Delegate&lt; R(A...), Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a faster replacement than std::function.  <a href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyBase.html">LoserTreeCopyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopyBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopy.html">LoserTreeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopy&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerBase.html">LoserTreePointerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointerBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointer.html">LoserTreePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointer&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguardedBase.html">LoserTreeCopyUnguardedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unguarded loser tree, copying the whole element into the tree structure.  <a href="classtlx_1_1LoserTreeCopyUnguardedBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguarded.html">LoserTreeCopyUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguardedBase.html">LoserTreePointerUnguardedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unguarded loser tree, keeping only pointers to the elements in the tree structure.  <a href="classtlx_1_1LoserTreePointerUnguardedBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguarded.html">LoserTreePointerUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeTraits.html">LoserTreeTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LruCacheSet.html">LruCacheSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an expected O(1) LRU cache which contains a set of key-only elements.  <a href="classtlx_1_1LruCacheSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LruCacheMap.html">LruCacheMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an expected O(1) LRU cache which contains a map of (key -&gt; value) elements.  <a href="classtlx_1_1LruCacheMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1FunctionChain.html">FunctionChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtlx_1_1FunctionChain.html" title="A FunctionChain is a chain of functors that can be folded to a single functors.">FunctionChain</a> is a chain of functors that can be folded to a single functors.  <a href="classtlx_1_1FunctionChain.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1FunctionStack.html">FunctionStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a> is a chain of functor that can be folded to a single functor (which is usually optimize by the compiler).  <a href="classtlx_1_1FunctionStack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1index__sequence.html">index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1make__index__sequence.html">make_index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is std::array&lt;T, N&gt;  <a href="structtlx_1_1is__std__array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__array_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">is_std_array&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__pair.html">is_std_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is a std::pair&lt;...&gt;  <a href="structtlx_1_1is__std__pair.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__pair_3_01std_1_1pair_3_01S_00_01T_01_4_01_4.html">is_std_pair&lt; std::pair&lt; S, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is a std::tuple&lt;...&gt;  <a href="structtlx_1_1is__std__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_4_01_4.html">is_std_tuple&lt; std::tuple&lt; Ts...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is std::vector&lt;T&gt;  <a href="structtlx_1_1is__std__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__vector_3_01std_1_1vector_3_01T_01_4_01_4.html">is_std_vector&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor.html">Log2Floor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor_3_011_01_4.html">Log2Floor&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor_3_010_01_4.html">Log2Floor&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2.html">Log2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2_3_011_01_4.html">Log2&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2_3_010_01_4.html">Log2&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1StaticIndex.html">StaticIndex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for <a class="el" href="namespacetlx.html#a9a8854506459ec185c2bcbdd6fe6428b" title="Call a generic functor (like a generic lambda) for each variadic template argument together with its ...">call_foreach_with_index()</a> to save the index as a compile-time index.  <a href="structtlx_1_1StaticIndex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1RingBuffer.html">RingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ring (circular) buffer of static (non-growing) size.  <a href="classtlx_1_1RingBuffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler non-growing vector without initialization.  <a href="classtlx_1_1SimpleVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StackArena.html">StackArena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage area allocated on the stack and usable by a <a class="el" href="classtlx_1_1StackAllocator.html">StackAllocator</a>.  <a href="classtlx_1_1StackArena.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StackAllocator.html">StackAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtlx_1_1ThreadPool.html" title="ThreadPool starts a fixed number p of std::threads which process Jobs that are enqueued into a concur...">ThreadPool</a> starts a fixed number p of std::threads which process Jobs that are enqueued into a concurrent job queue.  <a href="classtlx_1_1ThreadPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a04bc5251c951eb916e531c15ff43c8c2"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a04bc5251c951eb916e531c15ff43c8c2"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a04bc5251c951eb916e531c15ff43c8c2">counting_ptr</a> = <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;</td></tr>
<tr class="memdesc:a04bc5251c951eb916e531c15ff43c8c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to similarity with std::shared_ptr&lt;T&gt;  <a href="#a04bc5251c951eb916e531c15ff43c8c2">More...</a><br/></td></tr>
<tr class="separator:a04bc5251c951eb916e531c15ff43c8c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334d6d6f00442d92b91966a109d693d5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a334d6d6f00442d92b91966a109d693d5">reference_counter</a> = <a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:a334d6d6f00442d92b91966a109d693d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer.">CountingPtr</a>'s similarity with std::shared_ptr&lt;T&gt;  <a href="#a334d6d6f00442d92b91966a109d693d5">More...</a><br/></td></tr>
<tr class="separator:a334d6d6f00442d92b91966a109d693d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9c28df66ae41fedb3f537210097362"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a2c9c28df66ae41fedb3f537210097362"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2c9c28df66ae41fedb3f537210097362">delegate</a> = <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; T, Allocator &gt;</td></tr>
<tr class="memdesc:a2c9c28df66ae41fedb3f537210097362"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::function  <a href="#a2c9c28df66ae41fedb3f537210097362">More...</a><br/></td></tr>
<tr class="separator:a2c9c28df66ae41fedb3f537210097362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45001dd9f4f6324d2cf0b2aebd079f16"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a45001dd9f4f6324d2cf0b2aebd079f16"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a45001dd9f4f6324d2cf0b2aebd079f16">simple_vector</a> = <a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a>&lt; T &gt;</td></tr>
<tr class="memdesc:a45001dd9f4f6324d2cf0b2aebd079f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::vector  <a href="#a45001dd9f4f6324d2cf0b2aebd079f16">More...</a><br/></td></tr>
<tr class="separator:a45001dd9f4f6324d2cf0b2aebd079f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:aefb995468109a3061e9564adc91c3365"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aefb995468109a3061e9564adc91c3365">SimpleVectorMode</a> { <a class="el" href="namespacetlx.html#aefb995468109a3061e9564adc91c3365a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>, 
<a class="el" href="namespacetlx.html#aefb995468109a3061e9564adc91c3365a96726bf24e630d03d0f4e5715e9fd097">NoInitButDestroy</a>, 
<a class="el" href="namespacetlx.html#aefb995468109a3061e9564adc91c3365a60008b87abd54104caffab5779ea7244">NoInitNoDestroy</a>
 }</td></tr>
<tr class="memdesc:aefb995468109a3061e9564adc91c3365"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum class to select SimpleVector object initialization  <a href="namespacetlx.html#aefb995468109a3061e9564adc91c3365">More...</a><br/></td></tr>
<tr class="separator:aefb995468109a3061e9564adc91c3365"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae38d352a065543cf324f52a58bd2b026"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:ae38d352a065543cf324f52a58bd2b026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae38d352a065543cf324f52a58bd2b026">make_counting</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae38d352a065543cf324f52a58bd2b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">method analogous to std::make_shared and std::make_unique.  <a href="#ae38d352a065543cf324f52a58bd2b026">More...</a><br/></td></tr>
<tr class="separator:ae38d352a065543cf324f52a58bd2b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee8d3837365def6ce2290d6e76bd55"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5dee8d3837365def6ce2290d6e76bd55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5dee8d3837365def6ce2290d6e76bd55">swap</a> (<a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A &gt; &amp;a1, <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A &gt; &amp;a2) noexcept</td></tr>
<tr class="memdesc:a5dee8d3837365def6ce2290d6e76bd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap enclosed object with another counting pointer (no reference counts need change)  <a href="#a5dee8d3837365def6ce2290d6e76bd55">More...</a><br/></td></tr>
<tr class="separator:a5dee8d3837365def6ce2290d6e76bd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447e57b368c4ce87381d12d5cf1d8b12"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a447e57b368c4ce87381d12d5cf1d8b12"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a447e57b368c4ce87381d12d5cf1d8b12">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A &gt; &amp;c)</td></tr>
<tr class="memdesc:a447e57b368c4ce87381d12d5cf1d8b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">print pointer  <a href="#a447e57b368c4ce87381d12d5cf1d8b12">More...</a><br/></td></tr>
<tr class="separator:a447e57b368c4ce87381d12d5cf1d8b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184a6d51738969d70693ff4ab40e40db"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:a184a6d51738969d70693ff4ab40e40db"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a184a6d51738969d70693ff4ab40e40db">make_delegate</a> (C *const object_ptr, R(C::*const method_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:a184a6d51738969d70693ff4ab40e40db"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object pointer.  <a href="#a184a6d51738969d70693ff4ab40e40db">More...</a><br/></td></tr>
<tr class="separator:a184a6d51738969d70693ff4ab40e40db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e57fc132415d92776d9eed01ae3442"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:a36e57fc132415d92776d9eed01ae3442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e57fc132415d92776d9eed01ae3442">make_delegate</a> (C &amp;object_ptr, R(C::*const method_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:a36e57fc132415d92776d9eed01ae3442"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object reference.  <a href="#a36e57fc132415d92776d9eed01ae3442">More...</a><br/></td></tr>
<tr class="separator:a36e57fc132415d92776d9eed01ae3442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf10f085647ba34ff677aeecba994064"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:aaf10f085647ba34ff677aeecba994064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aaf10f085647ba34ff677aeecba994064">make_delegate</a> (C const &amp;object_ptr, R(C::*const method_ptr)(A...) const) noexcept</td></tr>
<tr class="memdesc:aaf10f085647ba34ff677aeecba994064"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object reference.  <a href="#aaf10f085647ba34ff677aeecba994064">More...</a><br/></td></tr>
<tr class="separator:aaf10f085647ba34ff677aeecba994064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189021baeabfe5b52ca34be6d94499b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4189021baeabfe5b52ca34be6d94499b">die_with_message</a> (const std::string &amp;msg)</td></tr>
<tr class="memdesc:a4189021baeabfe5b52ca34be6d94499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a4189021baeabfe5b52ca34be6d94499b">More...</a><br/></td></tr>
<tr class="separator:a4189021baeabfe5b52ca34be6d94499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4ea5cbffd44f2ec0ce8ed33a4a61f6a0">die_with_message</a> (const char *msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a4ea5cbffd44f2ec0ce8ed33a4a61f6a0">More...</a><br/></td></tr>
<tr class="separator:a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649f5837f3dd844a036e9a56534f4bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a649f5837f3dd844a036e9a56534f4bec">die_with_message</a> (const std::string &amp;msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:a649f5837f3dd844a036e9a56534f4bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a649f5837f3dd844a036e9a56534f4bec">More...</a><br/></td></tr>
<tr class="separator:a649f5837f3dd844a036e9a56534f4bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a659d0a374923911729663882bb4b"><td class="memTemplParams" colspan="2">template&lt;typename TypeA , typename TypeB &gt; </td></tr>
<tr class="memitem:a717a659d0a374923911729663882bb4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a717a659d0a374923911729663882bb4b">die_unequal_compare</a> (TypeA a, TypeB b)</td></tr>
<tr class="memdesc:a717a659d0a374923911729663882bb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb" title="Check that X == Y or die miserably, but output the values of X and Y for better debugging.">die_unequal()</a>  <a href="#a717a659d0a374923911729663882bb4b">More...</a><br/></td></tr>
<tr class="separator:a717a659d0a374923911729663882bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1550ff16b4ba586596da7f1f471abc"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7b1550ff16b4ba586596da7f1f471abc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7b1550ff16b4ba586596da7f1f471abc">die_unequal_compare</a> (float a, float b)</td></tr>
<tr class="separator:a7b1550ff16b4ba586596da7f1f471abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8b35ade280b3f91e8139002674d827"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abe8b35ade280b3f91e8139002674d827"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#abe8b35ade280b3f91e8139002674d827">die_unequal_compare</a> (double a, double b)</td></tr>
<tr class="separator:abe8b35ade280b3f91e8139002674d827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa901da3e5d75f6e1891f470b1382562e"><td class="memTemplParams" colspan="2">template&lt;typename IntegralN , typename IntegralK &gt; </td></tr>
<tr class="memitem:aa901da3e5d75f6e1891f470b1382562e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa901da3e5d75f6e1891f470b1382562e">div_ceil</a> (const IntegralN &amp;n, const IntegralK &amp;k) -&gt; decltype(n+k)</td></tr>
<tr class="memdesc:aa901da3e5d75f6e1891f470b1382562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate n div k with rounding up  <a href="#aa901da3e5d75f6e1891f470b1382562e">More...</a><br/></td></tr>
<tr class="separator:aa901da3e5d75f6e1891f470b1382562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b18ba30be90fbdad29253ee722c6ed1"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a6b18ba30be90fbdad29253ee722c6ed1"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6b18ba30be90fbdad29253ee722c6ed1">ffs_template</a> (Integral x)</td></tr>
<tr class="memdesc:a6b18ba30be90fbdad29253ee722c6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ffs (find first set bit) - generic implementation  <a href="#a6b18ba30be90fbdad29253ee722c6ed1">More...</a><br/></td></tr>
<tr class="separator:a6b18ba30be90fbdad29253ee722c6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac861b900d44fa2248a602d4b8ced1eaf"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac861b900d44fa2248a602d4b8ced1eaf">ffs</a> (int i)</td></tr>
<tr class="memdesc:ac861b900d44fa2248a602d4b8ced1eaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="#ac861b900d44fa2248a602d4b8ced1eaf">More...</a><br/></td></tr>
<tr class="separator:ac861b900d44fa2248a602d4b8ced1eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0f24041153abd2e823be870b1cb486"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4d0f24041153abd2e823be870b1cb486">ffs</a> (unsigned int i)</td></tr>
<tr class="memdesc:a4d0f24041153abd2e823be870b1cb486"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="#a4d0f24041153abd2e823be870b1cb486">More...</a><br/></td></tr>
<tr class="separator:a4d0f24041153abd2e823be870b1cb486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21dfab7db61d8154569f03422ae5980"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa21dfab7db61d8154569f03422ae5980">ffs</a> (long i)</td></tr>
<tr class="memdesc:aa21dfab7db61d8154569f03422ae5980"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="#aa21dfab7db61d8154569f03422ae5980">More...</a><br/></td></tr>
<tr class="separator:aa21dfab7db61d8154569f03422ae5980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10e04a16d93d00b465229ad8c7d98f5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa10e04a16d93d00b465229ad8c7d98f5">ffs</a> (unsigned long i)</td></tr>
<tr class="memdesc:aa10e04a16d93d00b465229ad8c7d98f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="#aa10e04a16d93d00b465229ad8c7d98f5">More...</a><br/></td></tr>
<tr class="separator:aa10e04a16d93d00b465229ad8c7d98f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fed4b94929c9332b72fcbbe6a192aa4"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a8fed4b94929c9332b72fcbbe6a192aa4">ffs</a> (long long i)</td></tr>
<tr class="memdesc:a8fed4b94929c9332b72fcbbe6a192aa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="#a8fed4b94929c9332b72fcbbe6a192aa4">More...</a><br/></td></tr>
<tr class="separator:a8fed4b94929c9332b72fcbbe6a192aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf3046a52cf9d692fdf33cb0bafb2135"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#abf3046a52cf9d692fdf33cb0bafb2135">ffs</a> (unsigned long long i)</td></tr>
<tr class="memdesc:abf3046a52cf9d692fdf33cb0bafb2135"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="#abf3046a52cf9d692fdf33cb0bafb2135">More...</a><br/></td></tr>
<tr class="separator:abf3046a52cf9d692fdf33cb0bafb2135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819e2d0d244166deaf699dbd962dfc4c"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType &gt; </td></tr>
<tr class="memitem:a819e2d0d244166deaf699dbd962dfc4c"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a819e2d0d244166deaf699dbd962dfc4c">integer_log2_floor_template</a> (IntegerType i)</td></tr>
<tr class="separator:a819e2d0d244166deaf699dbd962dfc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df455c67c152625835c3960651fa8d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a49df455c67c152625835c3960651fa8d">integer_log2_floor</a> (int i)</td></tr>
<tr class="memdesc:a49df455c67c152625835c3960651fa8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="#a49df455c67c152625835c3960651fa8d">More...</a><br/></td></tr>
<tr class="separator:a49df455c67c152625835c3960651fa8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a329db427c164e8e18d5768bf39f5907b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a329db427c164e8e18d5768bf39f5907b">integer_log2_floor</a> (unsigned int i)</td></tr>
<tr class="memdesc:a329db427c164e8e18d5768bf39f5907b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="#a329db427c164e8e18d5768bf39f5907b">More...</a><br/></td></tr>
<tr class="separator:a329db427c164e8e18d5768bf39f5907b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadbe93d286cd7f97cf551a79480db99"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#abadbe93d286cd7f97cf551a79480db99">integer_log2_floor</a> (long i)</td></tr>
<tr class="memdesc:abadbe93d286cd7f97cf551a79480db99"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="#abadbe93d286cd7f97cf551a79480db99">More...</a><br/></td></tr>
<tr class="separator:abadbe93d286cd7f97cf551a79480db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867fbf8cc4ac6cd7d257b52a55df0320"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a867fbf8cc4ac6cd7d257b52a55df0320">integer_log2_floor</a> (unsigned long i)</td></tr>
<tr class="memdesc:a867fbf8cc4ac6cd7d257b52a55df0320"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="#a867fbf8cc4ac6cd7d257b52a55df0320">More...</a><br/></td></tr>
<tr class="separator:a867fbf8cc4ac6cd7d257b52a55df0320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9c6e676fef1a542751ea36d6d8d9d"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aafe9c6e676fef1a542751ea36d6d8d9d">integer_log2_floor</a> (long long i)</td></tr>
<tr class="memdesc:aafe9c6e676fef1a542751ea36d6d8d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="#aafe9c6e676fef1a542751ea36d6d8d9d">More...</a><br/></td></tr>
<tr class="separator:aafe9c6e676fef1a542751ea36d6d8d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a281c59174d7e2d6f95f2a1a9c5a3f489"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a281c59174d7e2d6f95f2a1a9c5a3f489">integer_log2_floor</a> (unsigned long long i)</td></tr>
<tr class="memdesc:a281c59174d7e2d6f95f2a1a9c5a3f489"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="#a281c59174d7e2d6f95f2a1a9c5a3f489">More...</a><br/></td></tr>
<tr class="separator:a281c59174d7e2d6f95f2a1a9c5a3f489"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0623000e10bef6933e6ead2f1249440"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab0623000e10bef6933e6ead2f1249440">integer_log2_ceil</a> (int i)</td></tr>
<tr class="memdesc:ab0623000e10bef6933e6ead2f1249440"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="#ab0623000e10bef6933e6ead2f1249440">More...</a><br/></td></tr>
<tr class="separator:ab0623000e10bef6933e6ead2f1249440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac29ceb24428c6b50808522f0a2588f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a8ac29ceb24428c6b50808522f0a2588f">integer_log2_ceil</a> (unsigned int i)</td></tr>
<tr class="memdesc:a8ac29ceb24428c6b50808522f0a2588f"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="#a8ac29ceb24428c6b50808522f0a2588f">More...</a><br/></td></tr>
<tr class="separator:a8ac29ceb24428c6b50808522f0a2588f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f38e7475ac2db7ddb3a0c799e09044a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6f38e7475ac2db7ddb3a0c799e09044a">integer_log2_ceil</a> (long i)</td></tr>
<tr class="memdesc:a6f38e7475ac2db7ddb3a0c799e09044a"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="#a6f38e7475ac2db7ddb3a0c799e09044a">More...</a><br/></td></tr>
<tr class="separator:a6f38e7475ac2db7ddb3a0c799e09044a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030c7f4d9609d7b10128cfb9e51c3875"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a030c7f4d9609d7b10128cfb9e51c3875">integer_log2_ceil</a> (unsigned long i)</td></tr>
<tr class="memdesc:a030c7f4d9609d7b10128cfb9e51c3875"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="#a030c7f4d9609d7b10128cfb9e51c3875">More...</a><br/></td></tr>
<tr class="separator:a030c7f4d9609d7b10128cfb9e51c3875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa8bca2feafd224a051671fe5766642b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afa8bca2feafd224a051671fe5766642b">integer_log2_ceil</a> (long long i)</td></tr>
<tr class="memdesc:afa8bca2feafd224a051671fe5766642b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="#afa8bca2feafd224a051671fe5766642b">More...</a><br/></td></tr>
<tr class="separator:afa8bca2feafd224a051671fe5766642b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea719b8d9be1a47b69efa13f5045699"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#adea719b8d9be1a47b69efa13f5045699">integer_log2_ceil</a> (unsigned long long i)</td></tr>
<tr class="memdesc:adea719b8d9be1a47b69efa13f5045699"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="#adea719b8d9be1a47b69efa13f5045699">More...</a><br/></td></tr>
<tr class="separator:adea719b8d9be1a47b69efa13f5045699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd0c156caa682f81c584b29f1d62104"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a6bd0c156caa682f81c584b29f1d62104"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6bd0c156caa682f81c584b29f1d62104">is_power_of_two_template</a> (Integral i)</td></tr>
<tr class="separator:a6bd0c156caa682f81c584b29f1d62104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d557e827fc2c8cfa6f508ee51d91cd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1d557e827fc2c8cfa6f508ee51d91cd8">is_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:a1d557e827fc2c8cfa6f508ee51d91cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="#a1d557e827fc2c8cfa6f508ee51d91cd8">More...</a><br/></td></tr>
<tr class="separator:a1d557e827fc2c8cfa6f508ee51d91cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f792743feac6550c903768170f63f60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3f792743feac6550c903768170f63f60">is_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:a3f792743feac6550c903768170f63f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="#a3f792743feac6550c903768170f63f60">More...</a><br/></td></tr>
<tr class="separator:a3f792743feac6550c903768170f63f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deb83936763e3ed5c86fbe395f8cf56"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2deb83936763e3ed5c86fbe395f8cf56">is_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:a2deb83936763e3ed5c86fbe395f8cf56"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="#a2deb83936763e3ed5c86fbe395f8cf56">More...</a><br/></td></tr>
<tr class="separator:a2deb83936763e3ed5c86fbe395f8cf56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf55ffe8ee1bbbff99db8601f254610e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aaf55ffe8ee1bbbff99db8601f254610e">is_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:aaf55ffe8ee1bbbff99db8601f254610e"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="#aaf55ffe8ee1bbbff99db8601f254610e">More...</a><br/></td></tr>
<tr class="separator:aaf55ffe8ee1bbbff99db8601f254610e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d16d6977c0893d60731e085a1ca02d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a20d16d6977c0893d60731e085a1ca02d">is_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:a20d16d6977c0893d60731e085a1ca02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="#a20d16d6977c0893d60731e085a1ca02d">More...</a><br/></td></tr>
<tr class="separator:a20d16d6977c0893d60731e085a1ca02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f190fd8ea8769fd64df4b973c4a3b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a52f190fd8ea8769fd64df4b973c4a3b0">is_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:a52f190fd8ea8769fd64df4b973c4a3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="#a52f190fd8ea8769fd64df4b973c4a3b0">More...</a><br/></td></tr>
<tr class="separator:a52f190fd8ea8769fd64df4b973c4a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165140a3f756701491e3958c9858ea2c"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a165140a3f756701491e3958c9858ea2c"><td class="memTemplItemLeft" align="right" valign="top">static Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a165140a3f756701491e3958c9858ea2c">round_up_to_power_of_two_template</a> (Integral n)</td></tr>
<tr class="separator:a165140a3f756701491e3958c9858ea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece38332dbd324d658d87d90c9a5bf6a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aece38332dbd324d658d87d90c9a5bf6a">round_up_to_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:aece38332dbd324d658d87d90c9a5bf6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="#aece38332dbd324d658d87d90c9a5bf6a">More...</a><br/></td></tr>
<tr class="separator:aece38332dbd324d658d87d90c9a5bf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994588afad02e3d4a1aff864c4e0d352"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a994588afad02e3d4a1aff864c4e0d352">round_up_to_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:a994588afad02e3d4a1aff864c4e0d352"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="#a994588afad02e3d4a1aff864c4e0d352">More...</a><br/></td></tr>
<tr class="separator:a994588afad02e3d4a1aff864c4e0d352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f491ae70f43f57cc85744b148a7227"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a59f491ae70f43f57cc85744b148a7227">round_up_to_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:a59f491ae70f43f57cc85744b148a7227"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="#a59f491ae70f43f57cc85744b148a7227">More...</a><br/></td></tr>
<tr class="separator:a59f491ae70f43f57cc85744b148a7227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5997db3294cb9bdd4c2171c6dc69d23f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5997db3294cb9bdd4c2171c6dc69d23f">round_up_to_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:a5997db3294cb9bdd4c2171c6dc69d23f"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="#a5997db3294cb9bdd4c2171c6dc69d23f">More...</a><br/></td></tr>
<tr class="separator:a5997db3294cb9bdd4c2171c6dc69d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f753fbc4a8720d69d6af77b48f9ed14"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9f753fbc4a8720d69d6af77b48f9ed14">round_up_to_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:a9f753fbc4a8720d69d6af77b48f9ed14"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="#a9f753fbc4a8720d69d6af77b48f9ed14">More...</a><br/></td></tr>
<tr class="separator:a9f753fbc4a8720d69d6af77b48f9ed14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29783a06deb58a4fa231da5f76399b1c"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a29783a06deb58a4fa231da5f76399b1c">round_up_to_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:a29783a06deb58a4fa231da5f76399b1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="#a29783a06deb58a4fa231da5f76399b1c">More...</a><br/></td></tr>
<tr class="separator:a29783a06deb58a4fa231da5f76399b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ce4619242b36fd76f3b221ad9e0339"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a92ce4619242b36fd76f3b221ad9e0339">round_down_to_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:a92ce4619242b36fd76f3b221ad9e0339"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="#a92ce4619242b36fd76f3b221ad9e0339">More...</a><br/></td></tr>
<tr class="separator:a92ce4619242b36fd76f3b221ad9e0339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140d25c6b9c0222690efc97f8ad1a824"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a140d25c6b9c0222690efc97f8ad1a824">round_down_to_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:a140d25c6b9c0222690efc97f8ad1a824"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="#a140d25c6b9c0222690efc97f8ad1a824">More...</a><br/></td></tr>
<tr class="separator:a140d25c6b9c0222690efc97f8ad1a824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbfd1aed990afcb9984118d3ee59530"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6dbfd1aed990afcb9984118d3ee59530">round_down_to_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:a6dbfd1aed990afcb9984118d3ee59530"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="#a6dbfd1aed990afcb9984118d3ee59530">More...</a><br/></td></tr>
<tr class="separator:a6dbfd1aed990afcb9984118d3ee59530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d5d20f1d750595eb706751194589e1"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a73d5d20f1d750595eb706751194589e1">round_down_to_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:a73d5d20f1d750595eb706751194589e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="#a73d5d20f1d750595eb706751194589e1">More...</a><br/></td></tr>
<tr class="separator:a73d5d20f1d750595eb706751194589e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ad6167d69150c4d17040c640c18f40"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a65ad6167d69150c4d17040c640c18f40">round_down_to_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:a65ad6167d69150c4d17040c640c18f40"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="#a65ad6167d69150c4d17040c640c18f40">More...</a><br/></td></tr>
<tr class="separator:a65ad6167d69150c4d17040c640c18f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6738c012851741f46a8f189e99b3069e"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6738c012851741f46a8f189e99b3069e">round_down_to_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:a6738c012851741f46a8f189e99b3069e"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="#a6738c012851741f46a8f189e99b3069e">More...</a><br/></td></tr>
<tr class="separator:a6738c012851741f46a8f189e99b3069e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697505eebc05040893022611ce8866c1"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:a697505eebc05040893022611ce8866c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a697505eebc05040893022611ce8866c1">apply_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:a697505eebc05040893022611ce8866c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the functor f with the contents of t as arguments.  <a href="#a697505eebc05040893022611ce8866c1">More...</a><br/></td></tr>
<tr class="separator:a697505eebc05040893022611ce8866c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabdeef74e74806d7a81fa708ce9828e2"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Functor &gt; </td></tr>
<tr class="memitem:aabdeef74e74806d7a81fa708ce9828e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aabdeef74e74806d7a81fa708ce9828e2">call_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:aabdeef74e74806d7a81fa708ce9828e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for the integers [0,Size).  <a href="#aabdeef74e74806d7a81fa708ce9828e2">More...</a><br/></td></tr>
<tr class="separator:aabdeef74e74806d7a81fa708ce9828e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abdae3c630ff66ff635822c14f8c72a"><td class="memTemplParams" colspan="2">template&lt;size_t Begin, size_t End, typename Functor &gt; </td></tr>
<tr class="memitem:a2abdae3c630ff66ff635822c14f8c72a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2abdae3c630ff66ff635822c14f8c72a">call_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:a2abdae3c630ff66ff635822c14f8c72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for the integers [Begin,End).  <a href="#a2abdae3c630ff66ff635822c14f8c72a">More...</a><br/></td></tr>
<tr class="separator:a2abdae3c630ff66ff635822c14f8c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754cf6d5c1cb28e539cbc996af91ecb5"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a754cf6d5c1cb28e539cbc996af91ecb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a754cf6d5c1cb28e539cbc996af91ecb5">call_foreach</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a754cf6d5c1cb28e539cbc996af91ecb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for each variadic template argument.  <a href="#a754cf6d5c1cb28e539cbc996af91ecb5">More...</a><br/></td></tr>
<tr class="separator:a754cf6d5c1cb28e539cbc996af91ecb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a592749f0b74d1c116893d4bc880343e3"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:a592749f0b74d1c116893d4bc880343e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a592749f0b74d1c116893d4bc880343e3">call_foreach_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:a592749f0b74d1c116893d4bc880343e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) to each components of a tuple together with its zero-based index.  <a href="#a592749f0b74d1c116893d4bc880343e3">More...</a><br/></td></tr>
<tr class="separator:a592749f0b74d1c116893d4bc880343e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83551ec4ad5da9352345f7178abeb056"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:a83551ec4ad5da9352345f7178abeb056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a83551ec4ad5da9352345f7178abeb056">call_foreach_tuple_with_index</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:a83551ec4ad5da9352345f7178abeb056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) to each components of a tuple together with its zero-based index.  <a href="#a83551ec4ad5da9352345f7178abeb056">More...</a><br/></td></tr>
<tr class="separator:a83551ec4ad5da9352345f7178abeb056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8854506459ec185c2bcbdd6fe6428b"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a9a8854506459ec185c2bcbdd6fe6428b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9a8854506459ec185c2bcbdd6fe6428b">call_foreach_with_index</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9a8854506459ec185c2bcbdd6fe6428b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for each variadic template argument together with its zero-based index.  <a href="#a9a8854506459ec185c2bcbdd6fe6428b">More...</a><br/></td></tr>
<tr class="separator:a9a8854506459ec185c2bcbdd6fe6428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab2afc1ff7d0b9ea7a6583d0573e36ef7">make_function_chain</a> (const Functor &amp;functor)</td></tr>
<tr class="memdesc:ab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor chain maker. Can also be called with a lambda function.  <a href="#ab2afc1ff7d0b9ea7a6583d0573e36ef7">More...</a><br/></td></tr>
<tr class="separator:ab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2b32ffd2415899c6a69ccac4d7138f"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#add2b32ffd2415899c6a69ccac4d7138f">make_function_chain</a> ()</td></tr>
<tr class="memdesc:add2b32ffd2415899c6a69ccac4d7138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and empty function chain.  <a href="#add2b32ffd2415899c6a69ccac4d7138f">More...</a><br/></td></tr>
<tr class="separator:add2b32ffd2415899c6a69ccac4d7138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f5461dca9e4be26479c56a5500357e"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Functor &gt; </td></tr>
<tr class="memitem:af4f5461dca9e4be26479c56a5500357e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af4f5461dca9e4be26479c56a5500357e">make_function_stack</a> (const Functor &amp;functor)</td></tr>
<tr class="memdesc:af4f5461dca9e4be26479c56a5500357e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function-style construction of a <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a>.  <a href="#af4f5461dca9e4be26479c56a5500357e">More...</a><br/></td></tr>
<tr class="separator:af4f5461dca9e4be26479c56a5500357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a90b0de44f0e1aa17ae215db35f458"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a44a90b0de44f0e1aa17ae215db35f458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a44a90b0de44f0e1aa17ae215db35f458">vexpand</a> (Types &amp;&amp;...)</td></tr>
<tr class="separator:a44a90b0de44f0e1aa17ae215db35f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Functor &gt; </td></tr>
<tr class="memitem:a4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4a1c233e7ab713b8f8f77f7149f2bc4b">vmap_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:a4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vmap a generic functor (like a generic lambda) for the integers [0,Size).  <a href="#a4a1c233e7ab713b8f8f77f7149f2bc4b">More...</a><br/></td></tr>
<tr class="separator:a4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36807642146dd614b63d26ed6bba9c19"><td class="memTemplParams" colspan="2">template&lt;size_t Begin, size_t End, typename Functor &gt; </td></tr>
<tr class="memitem:a36807642146dd614b63d26ed6bba9c19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36807642146dd614b63d26ed6bba9c19">vmap_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:a36807642146dd614b63d26ed6bba9c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vmap a generic functor (like a generic lambda) for the integers [Begin,End).  <a href="#a36807642146dd614b63d26ed6bba9c19">More...</a><br/></td></tr>
<tr class="separator:a36807642146dd614b63d26ed6bba9c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af379571cbffcf0273d0203ef53bca2b8"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:af379571cbffcf0273d0203ef53bca2b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af379571cbffcf0273d0203ef53bca2b8">vmap_foreach</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:af379571cbffcf0273d0203ef53bca2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for each variadic template argument.  <a href="#af379571cbffcf0273d0203ef53bca2b8">More...</a><br/></td></tr>
<tr class="separator:af379571cbffcf0273d0203ef53bca2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a5c01183e4cc91ffbec284e8bd9437e"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:a1a5c01183e4cc91ffbec284e8bd9437e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1a5c01183e4cc91ffbec284e8bd9437e">vmap_foreach_with_index</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1a5c01183e4cc91ffbec284e8bd9437e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for each variadic template argument together with its zero-based index.  <a href="#a1a5c01183e4cc91ffbec284e8bd9437e">More...</a><br/></td></tr>
<tr class="separator:a1a5c01183e4cc91ffbec284e8bd9437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dd5bc7b975d74e87f79590c14d761f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab2dd5bc7b975d74e87f79590c14d761f">base64_encode</a> (const void *data, size_t size, size_t line_break=0)</td></tr>
<tr class="memdesc:ab2dd5bc7b975d74e87f79590c14d761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548.  <a href="#ab2dd5bc7b975d74e87f79590c14d761f">More...</a><br/></td></tr>
<tr class="separator:ab2dd5bc7b975d74e87f79590c14d761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa4ba3081a5e44addd2a616877d4d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af8aa4ba3081a5e44addd2a616877d4d6">base64_encode</a> (const std::string &amp;str, size_t line_break=0)</td></tr>
<tr class="memdesc:af8aa4ba3081a5e44addd2a616877d4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548.  <a href="#af8aa4ba3081a5e44addd2a616877d4d6">More...</a><br/></td></tr>
<tr class="separator:af8aa4ba3081a5e44addd2a616877d4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81eee6726695191b838c71cfab87775"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac81eee6726695191b838c71cfab87775">base64_decode</a> (const void *data, size_t size, bool strict=true)</td></tr>
<tr class="memdesc:ac81eee6726695191b838c71cfab87775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="#ac81eee6726695191b838c71cfab87775">More...</a><br/></td></tr>
<tr class="separator:ac81eee6726695191b838c71cfab87775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf60ffb92fd69bd1daf92ce2c30ce5d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acf60ffb92fd69bd1daf92ce2c30ce5d9">base64_decode</a> (const std::string &amp;str, bool strict=true)</td></tr>
<tr class="memdesc:acf60ffb92fd69bd1daf92ce2c30ce5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="#acf60ffb92fd69bd1daf92ce2c30ce5d9">More...</a><br/></td></tr>
<tr class="separator:acf60ffb92fd69bd1daf92ce2c30ce5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486913c9eb709bee76a0cd7d93756de7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a486913c9eb709bee76a0cd7d93756de7">compare_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:a486913c9eb709bee76a0cd7d93756de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#a486913c9eb709bee76a0cd7d93756de7">More...</a><br/></td></tr>
<tr class="separator:a486913c9eb709bee76a0cd7d93756de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e669da7cb69574c3ff44a4b8c0d2d2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7e669da7cb69574c3ff44a4b8c0d2d2d">compare_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a7e669da7cb69574c3ff44a4b8c0d2d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#a7e669da7cb69574c3ff44a4b8c0d2d2d">More...</a><br/></td></tr>
<tr class="separator:a7e669da7cb69574c3ff44a4b8c0d2d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ae3776db63cbe85af3108c8278f1797"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6ae3776db63cbe85af3108c8278f1797">compare_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:a6ae3776db63cbe85af3108c8278f1797"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#a6ae3776db63cbe85af3108c8278f1797">More...</a><br/></td></tr>
<tr class="separator:a6ae3776db63cbe85af3108c8278f1797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a60953b25c41cbcf3063af3755c8d89"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2a60953b25c41cbcf3063af3755c8d89">compare_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a2a60953b25c41cbcf3063af3755c8d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#a2a60953b25c41cbcf3063af3755c8d89">More...</a><br/></td></tr>
<tr class="separator:a2a60953b25c41cbcf3063af3755c8d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8724325030d7e986fe1983442d8210e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad8724325030d7e986fe1983442d8210e">contains</a> (const std::string &amp;str, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:ad8724325030d7e986fe1983442d8210e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="#ad8724325030d7e986fe1983442d8210e">More...</a><br/></td></tr>
<tr class="separator:ad8724325030d7e986fe1983442d8210e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae716c88d7aef5010fdda97d290f445c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae716c88d7aef5010fdda97d290f445c4">contains</a> (const std::string &amp;str, const char *pattern)</td></tr>
<tr class="memdesc:ae716c88d7aef5010fdda97d290f445c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="#ae716c88d7aef5010fdda97d290f445c4">More...</a><br/></td></tr>
<tr class="separator:ae716c88d7aef5010fdda97d290f445c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2178da8d848044033213718b263a8241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2178da8d848044033213718b263a8241">contains</a> (const std::string &amp;str, const char ch)</td></tr>
<tr class="memdesc:a2178da8d848044033213718b263a8241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains character.  <a href="#a2178da8d848044033213718b263a8241">More...</a><br/></td></tr>
<tr class="separator:a2178da8d848044033213718b263a8241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebcd1b9a6ce6667c8bbcab36aeaadb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7aebcd1b9a6ce6667c8bbcab36aeaadb">is_white</a> (char c)</td></tr>
<tr class="separator:a7aebcd1b9a6ce6667c8bbcab36aeaadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a636174561338cc674626246574319f51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a636174561338cc674626246574319f51">contains_word</a> (const std::string &amp;str, const char *word)</td></tr>
<tr class="memdesc:a636174561338cc674626246574319f51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="#a636174561338cc674626246574319f51">More...</a><br/></td></tr>
<tr class="separator:a636174561338cc674626246574319f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cad09f50452d7a29b354e1689d7c2be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a8cad09f50452d7a29b354e1689d7c2be">contains_word</a> (const std::string &amp;str, const std::string &amp;word)</td></tr>
<tr class="memdesc:a8cad09f50452d7a29b354e1689d7c2be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="#a8cad09f50452d7a29b354e1689d7c2be">More...</a><br/></td></tr>
<tr class="separator:a8cad09f50452d7a29b354e1689d7c2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6733a80c87e8184aa2dfda13f27db213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6733a80c87e8184aa2dfda13f27db213">ends_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:a6733a80c87e8184aa2dfda13f27db213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#a6733a80c87e8184aa2dfda13f27db213">More...</a><br/></td></tr>
<tr class="separator:a6733a80c87e8184aa2dfda13f27db213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9b803169617726fdcd5067e6077c35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9b9b803169617726fdcd5067e6077c35">ends_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a9b9b803169617726fdcd5067e6077c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#a9b9b803169617726fdcd5067e6077c35">More...</a><br/></td></tr>
<tr class="separator:a9b9b803169617726fdcd5067e6077c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d016f374292dbdce16a2cf92167132"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad6d016f374292dbdce16a2cf92167132">ends_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ad6d016f374292dbdce16a2cf92167132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#ad6d016f374292dbdce16a2cf92167132">More...</a><br/></td></tr>
<tr class="separator:ad6d016f374292dbdce16a2cf92167132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee97aa9588a7f1009590df7f7d23da6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9ee97aa9588a7f1009590df7f7d23da6">ends_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a9ee97aa9588a7f1009590df7f7d23da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#a9ee97aa9588a7f1009590df7f7d23da6">More...</a><br/></td></tr>
<tr class="separator:a9ee97aa9588a7f1009590df7f7d23da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3efff50dd5a42787dab2c0ee7570850"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af3efff50dd5a42787dab2c0ee7570850">equal_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:af3efff50dd5a42787dab2c0ee7570850"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#af3efff50dd5a42787dab2c0ee7570850">More...</a><br/></td></tr>
<tr class="separator:af3efff50dd5a42787dab2c0ee7570850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518a78bd2cd52b926e645b56bf110cec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a518a78bd2cd52b926e645b56bf110cec">equal_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a518a78bd2cd52b926e645b56bf110cec"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#a518a78bd2cd52b926e645b56bf110cec">More...</a><br/></td></tr>
<tr class="separator:a518a78bd2cd52b926e645b56bf110cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a330d5443500bd8cc5c782af5dedd6e3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a330d5443500bd8cc5c782af5dedd6e3d">equal_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:a330d5443500bd8cc5c782af5dedd6e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#a330d5443500bd8cc5c782af5dedd6e3d">More...</a><br/></td></tr>
<tr class="separator:a330d5443500bd8cc5c782af5dedd6e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf061126e1fd7ae64d3d59650bc7f51f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acf061126e1fd7ae64d3d59650bc7f51f">equal_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:acf061126e1fd7ae64d3d59650bc7f51f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#acf061126e1fd7ae64d3d59650bc7f51f">More...</a><br/></td></tr>
<tr class="separator:acf061126e1fd7ae64d3d59650bc7f51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512e3d39d925ff7b375788af6e97c710"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a512e3d39d925ff7b375788af6e97c710">erase_all</a> (std::string *str, char drop= ' ')</td></tr>
<tr class="memdesc:a512e3d39d925ff7b375788af6e97c710"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character in-place.  <a href="#a512e3d39d925ff7b375788af6e97c710">More...</a><br/></td></tr>
<tr class="separator:a512e3d39d925ff7b375788af6e97c710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c474b5f7238c0f277013aa7186954"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a050c474b5f7238c0f277013aa7186954">erase_all</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:a050c474b5f7238c0f277013aa7186954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="#a050c474b5f7238c0f277013aa7186954">More...</a><br/></td></tr>
<tr class="separator:a050c474b5f7238c0f277013aa7186954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973d7810f87779109aa972c52bc42d2f"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a973d7810f87779109aa972c52bc42d2f">erase_all</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a973d7810f87779109aa972c52bc42d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="#a973d7810f87779109aa972c52bc42d2f">More...</a><br/></td></tr>
<tr class="separator:a973d7810f87779109aa972c52bc42d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bcf861d481955f1cf2d04063e2cc9f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af5bcf861d481955f1cf2d04063e2cc9f">erase_all</a> (const std::string &amp;str, char drop= ' ')</td></tr>
<tr class="memdesc:af5bcf861d481955f1cf2d04063e2cc9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character, return copy of string.  <a href="#af5bcf861d481955f1cf2d04063e2cc9f">More...</a><br/></td></tr>
<tr class="separator:af5bcf861d481955f1cf2d04063e2cc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae93b67caac323e5a73f876bd7d760e5c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae93b67caac323e5a73f876bd7d760e5c">erase_all</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ae93b67caac323e5a73f876bd7d760e5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="#ae93b67caac323e5a73f876bd7d760e5c">More...</a><br/></td></tr>
<tr class="separator:ae93b67caac323e5a73f876bd7d760e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9badf37d1c25afa12bd26e59f1598b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1d9badf37d1c25afa12bd26e59f1598b">erase_all</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a1d9badf37d1c25afa12bd26e59f1598b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="#a1d9badf37d1c25afa12bd26e59f1598b">More...</a><br/></td></tr>
<tr class="separator:a1d9badf37d1c25afa12bd26e59f1598b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a431f26c247cf7f90bbe22c0c8e88721f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a431f26c247cf7f90bbe22c0c8e88721f">escape_html</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a431f26c247cf7f90bbe22c0c8e88721f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="#a431f26c247cf7f90bbe22c0c8e88721f">More...</a><br/></td></tr>
<tr class="separator:a431f26c247cf7f90bbe22c0c8e88721f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b37ed241994f71049ac60b552008aa1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2b37ed241994f71049ac60b552008aa1">escape_uri</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:a2b37ed241994f71049ac60b552008aa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="#a2b37ed241994f71049ac60b552008aa1">More...</a><br/></td></tr>
<tr class="separator:a2b37ed241994f71049ac60b552008aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ac2439a4b7a17a0e089c443249e67"><td class="memTemplParams" colspan="2">template&lt;typename Separator1 , typename Separator2 &gt; </td></tr>
<tr class="memitem:a536ac2439a4b7a17a0e089c443249e67"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a536ac2439a4b7a17a0e089c443249e67">extract_between_template</a> (const std::string &amp;str, const Separator1 &amp;sep1, size_t sep1_size, const Separator2 &amp;sep2)</td></tr>
<tr class="separator:a536ac2439a4b7a17a0e089c443249e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede55d891bc7ef14c3487c92b9adbe2b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aede55d891bc7ef14c3487c92b9adbe2b">extract_between</a> (const std::string &amp;str, const char *sep1, const char *sep2)</td></tr>
<tr class="memdesc:aede55d891bc7ef14c3487c92b9adbe2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#aede55d891bc7ef14c3487c92b9adbe2b">More...</a><br/></td></tr>
<tr class="separator:aede55d891bc7ef14c3487c92b9adbe2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a3de55eb7a37adb94f265716ab1269"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a07a3de55eb7a37adb94f265716ab1269">extract_between</a> (const std::string &amp;str, const char *sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:a07a3de55eb7a37adb94f265716ab1269"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#a07a3de55eb7a37adb94f265716ab1269">More...</a><br/></td></tr>
<tr class="separator:a07a3de55eb7a37adb94f265716ab1269"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77b920cac51ad74d0100a4ae73992b8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af77b920cac51ad74d0100a4ae73992b8">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const char *sep2)</td></tr>
<tr class="memdesc:af77b920cac51ad74d0100a4ae73992b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#af77b920cac51ad74d0100a4ae73992b8">More...</a><br/></td></tr>
<tr class="separator:af77b920cac51ad74d0100a4ae73992b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e62fde6d4c1881bed7cdec2ede5a080"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1e62fde6d4c1881bed7cdec2ede5a080">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:a1e62fde6d4c1881bed7cdec2ede5a080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#a1e62fde6d4c1881bed7cdec2ede5a080">More...</a><br/></td></tr>
<tr class="separator:a1e62fde6d4c1881bed7cdec2ede5a080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab562960c36651ded93c09da49c82a2cd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab562960c36651ded93c09da49c82a2cd">format_si_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ab562960c36651ded93c09da49c82a2cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TB.  <a href="#ab562960c36651ded93c09da49c82a2cd">More...</a><br/></td></tr>
<tr class="separator:ab562960c36651ded93c09da49c82a2cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acce90a4e027f6e52ef1598392d39568f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acce90a4e027f6e52ef1598392d39568f">format_iec_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:acce90a4e027f6e52ef1598392d39568f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TiB.  <a href="#acce90a4e027f6e52ef1598392d39568f">More...</a><br/></td></tr>
<tr class="separator:acce90a4e027f6e52ef1598392d39568f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1745dfeabacc1acb2d27abbcf553f844"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1745dfeabacc1acb2d27abbcf553f844">hexdump</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:a1745dfeabacc1acb2d27abbcf553f844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="#a1745dfeabacc1acb2d27abbcf553f844">More...</a><br/></td></tr>
<tr class="separator:a1745dfeabacc1acb2d27abbcf553f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec662b890f0da83582e7df6e3c55bf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3bec662b890f0da83582e7df6e3c55bf">hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a3bec662b890f0da83582e7df6e3c55bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="#a3bec662b890f0da83582e7df6e3c55bf">More...</a><br/></td></tr>
<tr class="separator:a3bec662b890f0da83582e7df6e3c55bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe26c3965f170d5367f8132ca9d4d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6cfe26c3965f170d5367f8132ca9d4d6">hexdump</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:a6cfe26c3965f170d5367f8132ca9d4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of uppercase hexadecimal pairs.  <a href="#a6cfe26c3965f170d5367f8132ca9d4d6">More...</a><br/></td></tr>
<tr class="separator:a6cfe26c3965f170d5367f8132ca9d4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab45f7bc3142c72619094a9d77069f1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#adab45f7bc3142c72619094a9d77069f1">hexdump</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:adab45f7bc3142c72619094a9d77069f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs.  <a href="#adab45f7bc3142c72619094a9d77069f1">More...</a><br/></td></tr>
<tr class="separator:adab45f7bc3142c72619094a9d77069f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43ee9db15046fbe68445eaec4e5c163"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae43ee9db15046fbe68445eaec4e5c163">hexdump_sourcecode</a> (const std::string &amp;str, const std::string &amp;var_name=&quot;name&quot;)</td></tr>
<tr class="memdesc:ae43ee9db15046fbe68445eaec4e5c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string into a C source code snippet.  <a href="#ae43ee9db15046fbe68445eaec4e5c163">More...</a><br/></td></tr>
<tr class="separator:ae43ee9db15046fbe68445eaec4e5c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23f2e36a532089a7b49e0c593cbe26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3e23f2e36a532089a7b49e0c593cbe26">hexdump_lc</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:a3e23f2e36a532089a7b49e0c593cbe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="#a3e23f2e36a532089a7b49e0c593cbe26">More...</a><br/></td></tr>
<tr class="separator:a3e23f2e36a532089a7b49e0c593cbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b479ab381ff2e7de94b87708f342c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a78b479ab381ff2e7de94b87708f342c1">hexdump_lc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a78b479ab381ff2e7de94b87708f342c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="#a78b479ab381ff2e7de94b87708f342c1">More...</a><br/></td></tr>
<tr class="separator:a78b479ab381ff2e7de94b87708f342c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ef6db6f00972ce269a6205002895b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a81ef6db6f00972ce269a6205002895b2">hexdump_lc</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:a81ef6db6f00972ce269a6205002895b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of lowercase hexadecimal pairs.  <a href="#a81ef6db6f00972ce269a6205002895b2">More...</a><br/></td></tr>
<tr class="separator:a81ef6db6f00972ce269a6205002895b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f65ffd0e8ea4503a9c9a5b681468722"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a0f65ffd0e8ea4503a9c9a5b681468722">hexdump_lc</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:a0f65ffd0e8ea4503a9c9a5b681468722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs.  <a href="#a0f65ffd0e8ea4503a9c9a5b681468722">More...</a><br/></td></tr>
<tr class="separator:a0f65ffd0e8ea4503a9c9a5b681468722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f3b68b2a872a4720a493a1dcdb0ae7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a15f3b68b2a872a4720a493a1dcdb0ae7">parse_hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a15f3b68b2a872a4720a493a1dcdb0ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string as a sequence of hexadecimal pairs.  <a href="#a15f3b68b2a872a4720a493a1dcdb0ae7">More...</a><br/></td></tr>
<tr class="separator:a15f3b68b2a872a4720a493a1dcdb0ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a485134f5e618b846abb630d44ec6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ae2a485134f5e618b846abb630d44ec6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae2a485134f5e618b846abb630d44ec6f">hexdump_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:ae2a485134f5e618b846abb630d44ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of uppercase hexadecimal pairs.  <a href="#ae2a485134f5e618b846abb630d44ec6f">More...</a><br/></td></tr>
<tr class="separator:ae2a485134f5e618b846abb630d44ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a0b2f444830d8f7b1b0eaf93b5f514bf7">hexdump_lc_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of lowercase hexadecimal pairs.  <a href="#a0b2f444830d8f7b1b0eaf93b5f514bf7">More...</a><br/></td></tr>
<tr class="separator:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0803e79d9afd1da9bf6c70599031ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1e0803e79d9afd1da9bf6c70599031ee">join</a> (char glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:a1e0803e79d9afd1da9bf6c70599031ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue character between each pair from the sequence.  <a href="#a1e0803e79d9afd1da9bf6c70599031ee">More...</a><br/></td></tr>
<tr class="separator:a1e0803e79d9afd1da9bf6c70599031ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e95b9812cee008cbdbcb30cc73531c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a51e95b9812cee008cbdbcb30cc73531c">join</a> (const char *glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:a51e95b9812cee008cbdbcb30cc73531c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="#a51e95b9812cee008cbdbcb30cc73531c">More...</a><br/></td></tr>
<tr class="separator:a51e95b9812cee008cbdbcb30cc73531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a754a19d10bba45d654c79cfec23d37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6a754a19d10bba45d654c79cfec23d37">join</a> (const std::string &amp;glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:a6a754a19d10bba45d654c79cfec23d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="#a6a754a19d10bba45d654c79cfec23d37">More...</a><br/></td></tr>
<tr class="separator:a6a754a19d10bba45d654c79cfec23d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af0448079469f224ea8905c34dc1868"><td class="memTemplParams" colspan="2">template&lt;typename Glue , typename Iterator &gt; </td></tr>
<tr class="memitem:a1af0448079469f224ea8905c34dc1868"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1af0448079469f224ea8905c34dc1868">join</a> (Glue glue, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:a1af0448079469f224ea8905c34dc1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a sequence of strings by some glue string between each pair from the sequence.  <a href="#a1af0448079469f224ea8905c34dc1868">More...</a><br/></td></tr>
<tr class="separator:a1af0448079469f224ea8905c34dc1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4a96227b0edd6c65800124ba1dac82cf">join</a> (char glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:a4a96227b0edd6c65800124ba1dac82cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue character between each pair from the sequence.  <a href="#a4a96227b0edd6c65800124ba1dac82cf">More...</a><br/></td></tr>
<tr class="separator:a4a96227b0edd6c65800124ba1dac82cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:affea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#affea57c0c1e61aa8c9bc50e1ec2f9fe2">join</a> (const char *glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:affea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="#affea57c0c1e61aa8c9bc50e1ec2f9fe2">More...</a><br/></td></tr>
<tr class="separator:affea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2e35ca12bd4564ba470e3bf4f6a91798">join</a> (const std::string &amp;glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:a2e35ca12bd4564ba470e3bf4f6a91798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="#a2e35ca12bd4564ba470e3bf4f6a91798">More...</a><br/></td></tr>
<tr class="separator:a2e35ca12bd4564ba470e3bf4f6a91798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a69ef70f3271d78ba48f36e9c3ce8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa6a69ef70f3271d78ba48f36e9c3ce8d">less_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:aa6a69ef70f3271d78ba48f36e9c3ce8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#aa6a69ef70f3271d78ba48f36e9c3ce8d">More...</a><br/></td></tr>
<tr class="separator:aa6a69ef70f3271d78ba48f36e9c3ce8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0d03bfa1f2fa2cf8f8f4211c1fea03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a0f0d03bfa1f2fa2cf8f8f4211c1fea03">less_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:a0f0d03bfa1f2fa2cf8f8f4211c1fea03"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#a0f0d03bfa1f2fa2cf8f8f4211c1fea03">More...</a><br/></td></tr>
<tr class="separator:a0f0d03bfa1f2fa2cf8f8f4211c1fea03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93f801299b061af29c7b9613fea4730"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab93f801299b061af29c7b9613fea4730">less_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ab93f801299b061af29c7b9613fea4730"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#ab93f801299b061af29c7b9613fea4730">More...</a><br/></td></tr>
<tr class="separator:ab93f801299b061af29c7b9613fea4730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3b710ccefae45bf1e1838bdc3785ce8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae3b710ccefae45bf1e1838bdc3785ce8">less_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ae3b710ccefae45bf1e1838bdc3785ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#ae3b710ccefae45bf1e1838bdc3785ce8">More...</a><br/></td></tr>
<tr class="separator:ae3b710ccefae45bf1e1838bdc3785ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fde10ed812d3e04d76c839583007973"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5fde10ed812d3e04d76c839583007973">pad</a> (const std::string &amp;s, size_t len, char pad_char= ' ')</td></tr>
<tr class="memdesc:a5fde10ed812d3e04d76c839583007973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate or pad string to exactly len characters.  <a href="#a5fde10ed812d3e04d76c839583007973">More...</a><br/></td></tr>
<tr class="separator:a5fde10ed812d3e04d76c839583007973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05df4ec244bd2d205d7b3a703f7a1849"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a05df4ec244bd2d205d7b3a703f7a1849">parse_si_iec_units</a> (const char *str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:a05df4ec244bd2d205d7b3a703f7a1849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="#a05df4ec244bd2d205d7b3a703f7a1849">More...</a><br/></td></tr>
<tr class="separator:a05df4ec244bd2d205d7b3a703f7a1849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3af33ea198b337b54631777267f9f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad3af33ea198b337b54631777267f9f03">parse_si_iec_units</a> (const std::string &amp;str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ad3af33ea198b337b54631777267f9f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="#ad3af33ea198b337b54631777267f9f03">More...</a><br/></td></tr>
<tr class="separator:ad3af33ea198b337b54631777267f9f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfd5af4ef681e5431a9dcc9b2f69fe"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab5bfd5af4ef681e5431a9dcc9b2f69fe">replace_first</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ab5bfd5af4ef681e5431a9dcc9b2f69fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ab5bfd5af4ef681e5431a9dcc9b2f69fe">More...</a><br/></td></tr>
<tr class="separator:ab5bfd5af4ef681e5431a9dcc9b2f69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d874ebb36fd5f67b57ed9181f94765"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad5d874ebb36fd5f67b57ed9181f94765">replace_first</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ad5d874ebb36fd5f67b57ed9181f94765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ad5d874ebb36fd5f67b57ed9181f94765">More...</a><br/></td></tr>
<tr class="separator:ad5d874ebb36fd5f67b57ed9181f94765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42af651055bba02cc39d2d2cfd5ddab"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa42af651055bba02cc39d2d2cfd5ddab">replace_first</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:aa42af651055bba02cc39d2d2cfd5ddab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#aa42af651055bba02cc39d2d2cfd5ddab">More...</a><br/></td></tr>
<tr class="separator:aa42af651055bba02cc39d2d2cfd5ddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682065cf1b811ca4ab97ca8198d39c5d"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a682065cf1b811ca4ab97ca8198d39c5d">replace_first</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:a682065cf1b811ca4ab97ca8198d39c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#a682065cf1b811ca4ab97ca8198d39c5d">More...</a><br/></td></tr>
<tr class="separator:a682065cf1b811ca4ab97ca8198d39c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a694e187e8049eb7dc29ff2b59c5f5566"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a694e187e8049eb7dc29ff2b59c5f5566">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:a694e187e8049eb7dc29ff2b59c5f5566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#a694e187e8049eb7dc29ff2b59c5f5566">More...</a><br/></td></tr>
<tr class="separator:a694e187e8049eb7dc29ff2b59c5f5566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e21587d2abcd727530592a5e10eca4c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2e21587d2abcd727530592a5e10eca4c">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:a2e21587d2abcd727530592a5e10eca4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#a2e21587d2abcd727530592a5e10eca4c">More...</a><br/></td></tr>
<tr class="separator:a2e21587d2abcd727530592a5e10eca4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd35eea795e85b2a1435155d3e655f52"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acd35eea795e85b2a1435155d3e655f52">replace_first</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:acd35eea795e85b2a1435155d3e655f52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#acd35eea795e85b2a1435155d3e655f52">More...</a><br/></td></tr>
<tr class="separator:acd35eea795e85b2a1435155d3e655f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aaf41622c559f40295d6136e2ea527a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a0aaf41622c559f40295d6136e2ea527a">replace_first</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:a0aaf41622c559f40295d6136e2ea527a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#a0aaf41622c559f40295d6136e2ea527a">More...</a><br/></td></tr>
<tr class="separator:a0aaf41622c559f40295d6136e2ea527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6441c2f401beebca1b130d5c0ede68"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#adf6441c2f401beebca1b130d5c0ede68">replace_all</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:adf6441c2f401beebca1b130d5c0ede68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#adf6441c2f401beebca1b130d5c0ede68">More...</a><br/></td></tr>
<tr class="separator:adf6441c2f401beebca1b130d5c0ede68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8073d342fc47ecdf76ad838e735aa57"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac8073d342fc47ecdf76ad838e735aa57">replace_all</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ac8073d342fc47ecdf76ad838e735aa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ac8073d342fc47ecdf76ad838e735aa57">More...</a><br/></td></tr>
<tr class="separator:ac8073d342fc47ecdf76ad838e735aa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b68830fd24a84d6b89c50a878f6d66a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5b68830fd24a84d6b89c50a878f6d66a">replace_all</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:a5b68830fd24a84d6b89c50a878f6d66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a5b68830fd24a84d6b89c50a878f6d66a">More...</a><br/></td></tr>
<tr class="separator:a5b68830fd24a84d6b89c50a878f6d66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a6fe09220e86f19f3451cee1e1e21"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7c3a6fe09220e86f19f3451cee1e1e21">replace_all</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:a7c3a6fe09220e86f19f3451cee1e1e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a7c3a6fe09220e86f19f3451cee1e1e21">More...</a><br/></td></tr>
<tr class="separator:a7c3a6fe09220e86f19f3451cee1e1e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9321abff9790139f91aa5f318d3674f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab9321abff9790139f91aa5f318d3674f">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ab9321abff9790139f91aa5f318d3674f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ab9321abff9790139f91aa5f318d3674f">More...</a><br/></td></tr>
<tr class="separator:ab9321abff9790139f91aa5f318d3674f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658c2a3f84c00c1654269b57aa18100c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a658c2a3f84c00c1654269b57aa18100c">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:a658c2a3f84c00c1654269b57aa18100c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a658c2a3f84c00c1654269b57aa18100c">More...</a><br/></td></tr>
<tr class="separator:a658c2a3f84c00c1654269b57aa18100c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377bdd21108edc0fda5a7bda408742a9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a377bdd21108edc0fda5a7bda408742a9">replace_all</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:a377bdd21108edc0fda5a7bda408742a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a377bdd21108edc0fda5a7bda408742a9">More...</a><br/></td></tr>
<tr class="separator:a377bdd21108edc0fda5a7bda408742a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac4636c5529e88f38fa2322cdb5cd735"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aac4636c5529e88f38fa2322cdb5cd735">replace_all</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:aac4636c5529e88f38fa2322cdb5cd735"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#aac4636c5529e88f38fa2322cdb5cd735">More...</a><br/></td></tr>
<tr class="separator:aac4636c5529e88f38fa2322cdb5cd735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3800f082eca7b380e4191684ff7cfade"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3800f082eca7b380e4191684ff7cfade">split</a> (char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:a3800f082eca7b380e4191684ff7cfade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#a3800f082eca7b380e4191684ff7cfade">More...</a><br/></td></tr>
<tr class="separator:a3800f082eca7b380e4191684ff7cfade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bde434fa34b9e603a1c053ac7f173a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a15bde434fa34b9e603a1c053ac7f173a">split</a> (const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:a15bde434fa34b9e603a1c053ac7f173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#a15bde434fa34b9e603a1c053ac7f173a">More...</a><br/></td></tr>
<tr class="separator:a15bde434fa34b9e603a1c053ac7f173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d975dfb31444851d8f5198fc0865c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad14d975dfb31444851d8f5198fc0865c">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ad14d975dfb31444851d8f5198fc0865c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ad14d975dfb31444851d8f5198fc0865c">More...</a><br/></td></tr>
<tr class="separator:ad14d975dfb31444851d8f5198fc0865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555f3c9768d7c087c8f29208fe14e41c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a555f3c9768d7c087c8f29208fe14e41c">split</a> (char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:a555f3c9768d7c087c8f29208fe14e41c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#a555f3c9768d7c087c8f29208fe14e41c">More...</a><br/></td></tr>
<tr class="separator:a555f3c9768d7c087c8f29208fe14e41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab399920b2f8a655e20dc10436ea5cf79"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab399920b2f8a655e20dc10436ea5cf79">split</a> (const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ab399920b2f8a655e20dc10436ea5cf79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ab399920b2f8a655e20dc10436ea5cf79">More...</a><br/></td></tr>
<tr class="separator:ab399920b2f8a655e20dc10436ea5cf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33b86a8d73bdc55660409d7c7f54a77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad33b86a8d73bdc55660409d7c7f54a77">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ad33b86a8d73bdc55660409d7c7f54a77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ad33b86a8d73bdc55660409d7c7f54a77">More...</a><br/></td></tr>
<tr class="separator:ad33b86a8d73bdc55660409d7c7f54a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43e0a4decab660095dbf98fa6151f16"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae43e0a4decab660095dbf98fa6151f16">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ae43e0a4decab660095dbf98fa6151f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#ae43e0a4decab660095dbf98fa6151f16">More...</a><br/></td></tr>
<tr class="separator:ae43e0a4decab660095dbf98fa6151f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88597e53210df27ef4d5db668a02fa7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae88597e53210df27ef4d5db668a02fa7">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, size_t sep_size, const std::string &amp;str, std::string::size_type limit)</td></tr>
<tr class="separator:ae88597e53210df27ef4d5db668a02fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb9b9c50ad82ec43bbf672f4b4caa4b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aecb9b9c50ad82ec43bbf672f4b4caa4b">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:aecb9b9c50ad82ec43bbf672f4b4caa4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#aecb9b9c50ad82ec43bbf672f4b4caa4b">More...</a><br/></td></tr>
<tr class="separator:aecb9b9c50ad82ec43bbf672f4b4caa4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ce983b04c074ca5138564e431d4a7b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a48ce983b04c074ca5138564e431d4a7b">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:a48ce983b04c074ca5138564e431d4a7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#a48ce983b04c074ca5138564e431d4a7b">More...</a><br/></td></tr>
<tr class="separator:a48ce983b04c074ca5138564e431d4a7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a9fa6574cdc019fa938fb003b12e49"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac0a9fa6574cdc019fa938fb003b12e49">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ac0a9fa6574cdc019fa938fb003b12e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#ac0a9fa6574cdc019fa938fb003b12e49">More...</a><br/></td></tr>
<tr class="separator:ac0a9fa6574cdc019fa938fb003b12e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757c5e0dddc69fceec20b6782477c98f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a757c5e0dddc69fceec20b6782477c98f">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:a757c5e0dddc69fceec20b6782477c98f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#a757c5e0dddc69fceec20b6782477c98f">More...</a><br/></td></tr>
<tr class="separator:a757c5e0dddc69fceec20b6782477c98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf4c1cb8940c98d9bc913f2b5bd087e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3cf4c1cb8940c98d9bc913f2b5bd087e">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:a3cf4c1cb8940c98d9bc913f2b5bd087e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#a3cf4c1cb8940c98d9bc913f2b5bd087e">More...</a><br/></td></tr>
<tr class="separator:a3cf4c1cb8940c98d9bc913f2b5bd087e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359648bf7e9bae0d45615233e24d2c12"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a359648bf7e9bae0d45615233e24d2c12">split_words</a> (const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:a359648bf7e9bae0d45615233e24d2c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string by whitespaces into distinct words.  <a href="#a359648bf7e9bae0d45615233e24d2c12">More...</a><br/></td></tr>
<tr class="separator:a359648bf7e9bae0d45615233e24d2c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50650708407ad9fd1dbc6fedc945678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab50650708407ad9fd1dbc6fedc945678">starts_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ab50650708407ad9fd1dbc6fedc945678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#ab50650708407ad9fd1dbc6fedc945678">More...</a><br/></td></tr>
<tr class="separator:ab50650708407ad9fd1dbc6fedc945678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409976857d6b184bd2ce6df6b367d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1409976857d6b184bd2ce6df6b367d6e">starts_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a1409976857d6b184bd2ce6df6b367d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#a1409976857d6b184bd2ce6df6b367d6e">More...</a><br/></td></tr>
<tr class="separator:a1409976857d6b184bd2ce6df6b367d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b33a83741bd5977c7769a4be7e43d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab4b33a83741bd5977c7769a4be7e43d0">starts_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ab4b33a83741bd5977c7769a4be7e43d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#ab4b33a83741bd5977c7769a4be7e43d0">More...</a><br/></td></tr>
<tr class="separator:ab4b33a83741bd5977c7769a4be7e43d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27633767ce2c4dc221acd4a331ec5c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a27633767ce2c4dc221acd4a331ec5c47">starts_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a27633767ce2c4dc221acd4a331ec5c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#a27633767ce2c4dc221acd4a331ec5c47">More...</a><br/></td></tr>
<tr class="separator:a27633767ce2c4dc221acd4a331ec5c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a517528748ca179557fe52d4e962e7859"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a517528748ca179557fe52d4e962e7859">to_lower</a> (char ch)</td></tr>
<tr class="memdesc:a517528748ca179557fe52d4e962e7859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to lower case without any localization.  <a href="#a517528748ca179557fe52d4e962e7859">More...</a><br/></td></tr>
<tr class="separator:a517528748ca179557fe52d4e962e7859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b550eadfca772df3e1c2ce3a581b02"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a26b550eadfca772df3e1c2ce3a581b02">to_lower</a> (std::string *str)</td></tr>
<tr class="memdesc:a26b550eadfca772df3e1c2ce3a581b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to lowercase and returns a reference to it.  <a href="#a26b550eadfca772df3e1c2ce3a581b02">More...</a><br/></td></tr>
<tr class="separator:a26b550eadfca772df3e1c2ce3a581b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5053e892d19dd4fe230e19928287b89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad5053e892d19dd4fe230e19928287b89">to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ad5053e892d19dd4fe230e19928287b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to lowercase.  <a href="#ad5053e892d19dd4fe230e19928287b89">More...</a><br/></td></tr>
<tr class="separator:ad5053e892d19dd4fe230e19928287b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef29005ad36974008f9c0a364878b855"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aef29005ad36974008f9c0a364878b855">to_upper</a> (char ch)</td></tr>
<tr class="memdesc:aef29005ad36974008f9c0a364878b855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to upper case without any localization.  <a href="#aef29005ad36974008f9c0a364878b855">More...</a><br/></td></tr>
<tr class="separator:aef29005ad36974008f9c0a364878b855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742b71bfffe387035f604bad0d1ff4aa"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a742b71bfffe387035f604bad0d1ff4aa">to_upper</a> (std::string *str)</td></tr>
<tr class="memdesc:a742b71bfffe387035f604bad0d1ff4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to uppercase and returns a reference to it.  <a href="#a742b71bfffe387035f604bad0d1ff4aa">More...</a><br/></td></tr>
<tr class="separator:a742b71bfffe387035f604bad0d1ff4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54387562dddddd389df250cdb15ade00"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a54387562dddddd389df250cdb15ade00">to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a54387562dddddd389df250cdb15ade00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to uppercase.  <a href="#a54387562dddddd389df250cdb15ade00">More...</a><br/></td></tr>
<tr class="separator:a54387562dddddd389df250cdb15ade00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc70026a4a1d57a74c7125f959245719"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afc70026a4a1d57a74c7125f959245719">trim</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:afc70026a4a1d57a74c7125f959245719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#afc70026a4a1d57a74c7125f959245719">More...</a><br/></td></tr>
<tr class="separator:afc70026a4a1d57a74c7125f959245719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1eecb0fadc2a1fddf598c7263ea4a9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3d1eecb0fadc2a1fddf598c7263ea4a9">trim</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a3d1eecb0fadc2a1fddf598c7263ea4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#a3d1eecb0fadc2a1fddf598c7263ea4a9">More...</a><br/></td></tr>
<tr class="separator:a3d1eecb0fadc2a1fddf598c7263ea4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793ce30c7b3cff3a6111b41b07e883e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a793ce30c7b3cff3a6111b41b07e883e1">trim</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:a793ce30c7b3cff3a6111b41b07e883e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#a793ce30c7b3cff3a6111b41b07e883e1">More...</a><br/></td></tr>
<tr class="separator:a793ce30c7b3cff3a6111b41b07e883e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32962b0cd33bfbad1b8b9f84d71171fc"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a32962b0cd33bfbad1b8b9f84d71171fc">trim</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a32962b0cd33bfbad1b8b9f84d71171fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#a32962b0cd33bfbad1b8b9f84d71171fc">More...</a><br/></td></tr>
<tr class="separator:a32962b0cd33bfbad1b8b9f84d71171fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ce44f04459898e5b6ca63ae5628c1f"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa6ce44f04459898e5b6ca63ae5628c1f">trim_right</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:aa6ce44f04459898e5b6ca63ae5628c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="#aa6ce44f04459898e5b6ca63ae5628c1f">More...</a><br/></td></tr>
<tr class="separator:aa6ce44f04459898e5b6ca63ae5628c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e285a6834d509909818f1c12303993"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e285a6834d509909818f1c12303993">trim_right</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a36e285a6834d509909818f1c12303993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="#a36e285a6834d509909818f1c12303993">More...</a><br/></td></tr>
<tr class="separator:a36e285a6834d509909818f1c12303993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db34075fd2fa8291d5784450c3ff7ef"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9db34075fd2fa8291d5784450c3ff7ef">trim_right</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:a9db34075fd2fa8291d5784450c3ff7ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="#a9db34075fd2fa8291d5784450c3ff7ef">More...</a><br/></td></tr>
<tr class="separator:a9db34075fd2fa8291d5784450c3ff7ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f5099884188aee9526e5f7a9aefc4a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a67f5099884188aee9526e5f7a9aefc4a">trim_right</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a67f5099884188aee9526e5f7a9aefc4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="#a67f5099884188aee9526e5f7a9aefc4a">More...</a><br/></td></tr>
<tr class="separator:a67f5099884188aee9526e5f7a9aefc4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95f062055820fcae0be3c5731217989"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa95f062055820fcae0be3c5731217989">trim_left</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:aa95f062055820fcae0be3c5731217989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="#aa95f062055820fcae0be3c5731217989">More...</a><br/></td></tr>
<tr class="separator:aa95f062055820fcae0be3c5731217989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e152d7231dc17cf6bbd32cb0c4fa21"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad2e152d7231dc17cf6bbd32cb0c4fa21">trim_left</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ad2e152d7231dc17cf6bbd32cb0c4fa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="#ad2e152d7231dc17cf6bbd32cb0c4fa21">More...</a><br/></td></tr>
<tr class="separator:ad2e152d7231dc17cf6bbd32cb0c4fa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51bb404a33a2f6f95c27a3ee392bc5d2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a51bb404a33a2f6f95c27a3ee392bc5d2">trim_left</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:a51bb404a33a2f6f95c27a3ee392bc5d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="#a51bb404a33a2f6f95c27a3ee392bc5d2">More...</a><br/></td></tr>
<tr class="separator:a51bb404a33a2f6f95c27a3ee392bc5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21eb3ad7a12fc40ddf705915556656c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac21eb3ad7a12fc40ddf705915556656c">trim_left</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ac21eb3ad7a12fc40ddf705915556656c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="#ac21eb3ad7a12fc40ddf705915556656c">More...</a><br/></td></tr>
<tr class="separator:ac21eb3ad7a12fc40ddf705915556656c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec6be6417fecf489c677756087b8599"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9ec6be6417fecf489c677756087b8599">union_words</a> (const std::string &amp;wordsA, const std::string &amp;wordsB)</td></tr>
<tr class="memdesc:a9ec6be6417fecf489c677756087b8599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return union of two keyword sets.  <a href="#a9ec6be6417fecf489c677756087b8599">More...</a><br/></td></tr>
<tr class="separator:a9ec6be6417fecf489c677756087b8599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab22e05055aa827de79236f0cb53354d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aab22e05055aa827de79236f0cb53354d">word_wrap</a> (const std::string &amp;str, unsigned int wrap=80)</td></tr>
<tr class="memdesc:aab22e05055aa827de79236f0cb53354d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to wrap a string to 80 columns without split words.  <a href="#aab22e05055aa827de79236f0cb53354d">More...</a><br/></td></tr>
<tr class="separator:aab22e05055aa827de79236f0cb53354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a63b398e6678264958fb8590e9332bf"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a5a63b398e6678264958fb8590e9332bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5a63b398e6678264958fb8590e9332bf">unused</a> (Types &amp;&amp;...)</td></tr>
<tr class="separator:a5a63b398e6678264958fb8590e9332bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a04bc5251c951eb916e531c15ff43c8c2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a04bc5251c951eb916e531c15ff43c8c2">tlx::counting_ptr</a> = typedef <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias due to similarity with std::shared_ptr&lt;T&gt; </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00240">240</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c9c28df66ae41fedb3f537210097362"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a2c9c28df66ae41fedb3f537210097362">tlx::delegate</a> = typedef <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;T, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make template alias due to similarity with std::function </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00426">426</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a334d6d6f00442d92b91966a109d693d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a334d6d6f00442d92b91966a109d693d5">tlx::reference_counter</a> = typedef <a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias due to <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer.">CountingPtr</a>'s similarity with std::shared_ptr&lt;T&gt; </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00320">320</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45001dd9f4f6324d2cf0b2aebd079f16"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a45001dd9f4f6324d2cf0b2aebd079f16">tlx::simple_vector</a> = typedef <a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make template alias due to similarity with std::vector </p>

<p>Definition at line <a class="el" href="simple__vector_8hpp_source.html#l00217">217</a> of file <a class="el" href="simple__vector_8hpp_source.html">simple_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aefb995468109a3061e9564adc91c3365"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetlx.html#aefb995468109a3061e9564adc91c3365">tlx::SimpleVectorMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>enum class to select <a class="el" href="classtlx_1_1SimpleVector.html" title="Simpler non-growing vector without initialization.">SimpleVector</a> object initialization </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="aefb995468109a3061e9564adc91c3365a960b44c579bc2f6818d2daaf9e4c16f0"></a>Normal</em>&nbsp;</td><td class="fielddoc">
<p>Initialize objects at allocation and destroy on deallocation. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aefb995468109a3061e9564adc91c3365a96726bf24e630d03d0f4e5715e9fd097"></a>NoInitButDestroy</em>&nbsp;</td><td class="fielddoc">
<p>Do not initialize objects at allocation, but destroy on deallocation. </p>
<p>Thus, all objects must be constructed from outside. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="aefb995468109a3061e9564adc91c3365a60008b87abd54104caffab5779ea7244"></a>NoInitNoDestroy</em>&nbsp;</td><td class="fielddoc">
<p>Do not initialize objects at allocation and do not destroy them. </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="simple__vector_8hpp_source.html#l00025">25</a> of file <a class="el" href="simple__vector_8hpp_source.html">simple_vector.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a697505eebc05040893022611ce8866c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tlx::apply_tuple </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call the functor f with the contents of t as arguments. </p>

<p>Definition at line <a class="el" href="apply__tuple_8hpp_source.html#l00036">36</a> of file <a class="el" href="apply__tuple_8hpp_source.html">apply_tuple.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac81eee6726695191b838c71cfab87775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to decode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to decode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00108">108</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf60ffb92fd69bd1daf92ce2c30ce5d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00203">203</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2dd5bc7b975d74e87f79590c14d761f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to encode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00025">25</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8aa4ba3081a5e44addd2a616877d4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00102">102</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabdeef74e74806d7a81fa708ce9828e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::call_for_range </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) for the integers [0,Size). </p>

<p>Definition at line <a class="el" href="call__for__range_8hpp_source.html#l00052">52</a> of file <a class="el" href="call__for__range_8hpp_source.html">call_for_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2abdae3c630ff66ff635822c14f8c72a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Begin, size_t End, typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::call_for_range </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) for the integers [Begin,End). </p>

<p>Definition at line <a class="el" href="call__for__range_8hpp_source.html#l00059">59</a> of file <a class="el" href="call__for__range_8hpp_source.html">call_for_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a754cf6d5c1cb28e539cbc996af91ecb5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::call_foreach </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) for each variadic template argument. </p>

<p>Definition at line <a class="el" href="call__foreach_8hpp_source.html#l00044">44</a> of file <a class="el" href="call__foreach_8hpp_source.html">call_foreach.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a592749f0b74d1c116893d4bc880343e3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::call_foreach_tuple </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) to each components of a tuple together with its zero-based index. </p>

<p>Definition at line <a class="el" href="call__foreach__tuple_8hpp_source.html#l00042">42</a> of file <a class="el" href="call__foreach__tuple_8hpp_source.html">call_foreach_tuple.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83551ec4ad5da9352345f7178abeb056"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::call_foreach_tuple_with_index </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) to each components of a tuple together with its zero-based index. </p>

<p>Definition at line <a class="el" href="call__foreach__tuple__with__index_8hpp_source.html#l00042">42</a> of file <a class="el" href="call__foreach__tuple__with__index_8hpp_source.html">call_foreach_tuple_with_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a8854506459ec185c2bcbdd6fe6428b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::call_foreach_with_index </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) for each variadic template argument together with its zero-based index. </p>

<p>Definition at line <a class="el" href="call__foreach__with__index_8hpp_source.html#l00047">47</a> of file <a class="el" href="call__foreach__with__index_8hpp_source.html">call_foreach_with_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a486913c9eb709bee76a0cd7d93756de7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tlx::compare_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7e669da7cb69574c3ff44a4b8c0d2d2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tlx::compare_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00035">35</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ae3776db63cbe85af3108c8278f1797"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tlx::compare_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00054">54</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a60953b25c41cbcf3063af3755c8d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tlx::compare_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00072">72</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad8724325030d7e986fe1983442d8210e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains pattern. </p>

<p>Definition at line <a class="el" href="contains_8cpp_source.html#l00015">15</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae716c88d7aef5010fdda97d290f445c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains pattern. </p>

<p>Definition at line <a class="el" href="contains_8cpp_source.html#l00019">19</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2178da8d848044033213718b263a8241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains character. </p>

<p>Definition at line <a class="el" href="contains_8cpp_source.html#l00023">23</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a636174561338cc674626246574319f51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::contains_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given string for a whitespace-delimited word. </p>
<p>It works as if the str was <a class="el" href="namespacetlx.html#a359648bf7e9bae0d45615233e24d2c12" title="Split the given string by whitespaces into distinct words.">split_words()</a> and the resulting vector checked for a given word. However this function does not create a vector, it scans the string directly. Whitespace is space, tab, newline or carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>whitespace-delimited string to check </td></tr>
    <tr><td class="paramname">word</td><td>word to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the word was found </dd></dl>

<p>Definition at line <a class="el" href="contains__word_8cpp_source.html#l00019">19</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8cad09f50452d7a29b354e1689d7c2be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::contains_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given string for a whitespace-delimited word. </p>
<p>It works as if the str was <a class="el" href="namespacetlx.html#a359648bf7e9bae0d45615233e24d2c12" title="Split the given string by whitespaces into distinct words.">split_words()</a> and the resulting vector checked for a given word. However this function does not create a vector, it scans the string directly. Whitespace is space, tab, newline or carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>whitespace-delimited string to check </td></tr>
    <tr><td class="paramname">word</td><td>word to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the word was found </dd></dl>

<p>Definition at line <a class="el" href="contains__word_8cpp_source.html#l00055">55</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a717a659d0a374923911729663882bb4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeA , typename TypeB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_unequal_compare </td>
          <td>(</td>
          <td class="paramtype">TypeA&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeB&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb" title="Check that X == Y or die miserably, but output the values of X and Y for better debugging.">die_unequal()</a> </p>

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00074">74</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b1550ff16b4ba586596da7f1f471abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_unequal_compare </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00079">79</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe8b35ade280b3f91e8139002674d827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_unequal_compare </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00085">85</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4189021baeabfe5b52ca34be6d94499b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00018">18</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::die_with_message </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00023">23</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a649f5837f3dd844a036e9a56534f4bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00029">29</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa901da3e5d75f6e1891f470b1382562e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegralN , typename IntegralK &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto tlx::div_ceil </td>
          <td>(</td>
          <td class="paramtype">const IntegralN &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const IntegralK &amp;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(n + k) </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculate n div k with rounding up </p>

<p>Definition at line <a class="el" href="div__ceil_8hpp_source.html#l00022">22</a> of file <a class="el" href="div__ceil_8hpp_source.html">div_ceil.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6733a80c87e8184aa2dfda13f27db213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00020">20</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b9b803169617726fdcd5067e6077c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00027">27</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6d016f374292dbdce16a2cf92167132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00044">44</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ee97aa9588a7f1009590df7f7d23da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00054">54</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af3efff50dd5a42787dab2c0ee7570850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::equal_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a518a78bd2cd52b926e645b56bf110cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::equal_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00026">26</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a330d5443500bd8cc5c782af5dedd6e3d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::equal_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00035">35</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf061126e1fd7ae64d3d59650bc7f51f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::equal_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00044">44</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a512e3d39d925ff7b375788af6e97c710"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>drop</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given character in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove this character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00018">18</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a050c474b5f7238c0f277013aa7186954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00034">34</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a973d7810f87779109aa972c52bc42d2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00050">50</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af5bcf861d481955f1cf2d04063e2cc9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>drop</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given character, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove this character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00057">57</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae93b67caac323e5a73f876bd7d760e5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00071">71</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d9badf37d1c25afa12bd26e59f1598b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00092">92</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a431f26c247cf7f90bbe22c0c8e88721f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::escape_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities. </p>

<p>Definition at line <a class="el" href="escape__html_8cpp_source.html#l00015">15</a> of file <a class="el" href="escape__html_8cpp_source.html">escape_html.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b37ed241994f71049ac60b552008aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::escape_uri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape a string into a URI-encoding. </p>
<p>This maps all non A-Z0-9 characters to HH hex representation. </p>

<p>Definition at line <a class="el" href="escape__uri_8cpp_source.html#l00015">15</a> of file <a class="el" href="escape__uri_8cpp_source.html">escape_uri.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aede55d891bc7ef14c3487c92b9adbe2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00037">37</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07a3de55eb7a37adb94f265716ab1269"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00042">42</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af77b920cac51ad74d0100a4ae73992b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00047">47</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e62fde6d4c1881bed7cdec2ede5a080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00052">52</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a536ac2439a4b7a17a0e089c443249e67"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Separator1 , typename Separator2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::extract_between_template </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Separator1 &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sep1_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Separator2 &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00019">19</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac861b900d44fa2248a602d4b8ced1eaf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::ffs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first set bit in integer, or zero if none are set. </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00050">50</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4d0f24041153abd2e823be870b1cb486"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::ffs </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first set bit in integer, or zero if none are set. </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00053">53</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa21dfab7db61d8154569f03422ae5980"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::ffs </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first set bit in integer, or zero if none are set. </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00056">56</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa10e04a16d93d00b465229ad8c7d98f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::ffs </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first set bit in integer, or zero if none are set. </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00059">59</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8fed4b94929c9332b72fcbbe6a192aa4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::ffs </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first set bit in integer, or zero if none are set. </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00062">62</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abf3046a52cf9d692fdf33cb0bafb2135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::ffs </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>find first set bit in integer, or zero if none are set. </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00065">65</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b18ba30be90fbdad29253ee722c6ed1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned tlx::ffs_template </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ffs (find first set bit) - generic implementation </p>

<p>Definition at line <a class="el" href="ffs_8cpp_source.html#l00017">17</a> of file <a class="el" href="ffs_8cpp_source.html">ffs.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acce90a4e027f6e52ef1598392d39568f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::format_iec_units </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number as something like 1 TiB. </p>
<p>Format a byte size using IEC (Ki, Mi, Gi, Ti) suffixes (powers of two).</p>
<p>Returns "123 Ki" or similar. </p>

<p>Definition at line <a class="el" href="format__si__iec__units_8cpp_source.html#l00038">38</a> of file <a class="el" href="format__si__iec__units_8cpp_source.html">format_si_iec_units.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab562960c36651ded93c09da49c82a2cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::format_si_units </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number as something like 1 TB. </p>
<p>Format a byte size using SI (K, M, G, T) suffixes (powers of ten).</p>
<p>Returns "123 M" or similar. </p>

<p>Definition at line <a class="el" href="format__si__iec__units_8cpp_source.html#l00019">19</a> of file <a class="el" href="format__si__iec__units_8cpp_source.html">format_si_iec_units.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1745dfeabacc1acb2d27abbcf553f844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00021">21</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bec662b890f0da83582e7df6e3c55bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00042">42</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cfe26c3965f170d5367f8132ca9d4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00046">46</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adab45f7bc3142c72619094a9d77069f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00050">50</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e23f2e36a532089a7b49e0c593cbe26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00095">95</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78b479ab381ff2e7de94b87708f342c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00116">116</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81ef6db6f00972ce269a6205002895b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00120">120</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f65ffd0e8ea4503a9c9a5b681468722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00124">124</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b2f444830d8f7b1b0eaf93b5f514bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8hpp_source.html#l00105">105</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae43ee9db15046fbe68445eaec4e5c163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_sourcecode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em> = <code>&quot;name&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string into a C source code snippet. </p>
<p>The snippet defines an array of const uint8_t* holding the data of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to output as C source array </td></tr>
    <tr><td class="paramname">var_name</td><td>name of the array variable in the outputted code snippet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding C source snippet </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00054">54</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2a485134f5e618b846abb630d44ec6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8hpp_source.html#l00047">47</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0623000e10bef6933e6ead2f1249440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 ceiling of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00052">52</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ac29ceb24428c6b50808522f0a2588f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 ceiling of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00057">57</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6f38e7475ac2db7ddb3a0c799e09044a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 ceiling of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00062">62</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a030c7f4d9609d7b10128cfb9e51c3875"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 ceiling of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00067">67</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa8bca2feafd224a051671fe5766642b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 ceiling of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00072">72</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adea719b8d9be1a47b69efa13f5045699"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_ceil </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 ceiling of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00077">77</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49df455c67c152625835c3960651fa8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_floor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 floor of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00026">26</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a329db427c164e8e18d5768bf39f5907b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_floor </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 floor of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00030">30</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="abadbe93d286cd7f97cf551a79480db99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_floor </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 floor of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00034">34</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a867fbf8cc4ac6cd7d257b52a55df0320"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_floor </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 floor of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00038">38</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aafe9c6e676fef1a542751ea36d6d8d9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_floor </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 floor of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00042">42</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a281c59174d7e2d6f95f2a1a9c5a3f489"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned tlx::integer_log2_floor </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate the log2 floor of an integer type (by repeated bit shifts) </p>

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00046">46</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a819e2d0d244166deaf699dbd962dfc4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntegerType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned tlx::integer_log2_floor_template </td>
          <td>(</td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00016">16</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d557e827fc2c8cfa6f508ee51d91cd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: true if i is a power of two </p>

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00023">23</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3f792743feac6550c903768170f63f60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: true if i is a power of two </p>

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00027">27</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2deb83936763e3ed5c86fbe395f8cf56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: true if i is a power of two </p>

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00031">31</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf55ffe8ee1bbbff99db8601f254610e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: true if i is a power of two </p>

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00035">35</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20d16d6977c0893d60731e085a1ca02d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: true if i is a power of two </p>

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00039">39</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52f190fd8ea8769fd64df4b973c4a3b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: true if i is a power of two </p>

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00043">43</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6bd0c156caa682f81c584b29f1d62104"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tlx::is_power_of_two_template </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00016">16</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7aebcd1b9a6ce6667c8bbcab36aeaadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tlx::is_white </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="contains__word_8cpp_source.html#l00015">15</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e0803e79d9afd1da9bf6c70599031ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue character between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>character for glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join_8cpp_source.html#l00016">16</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51e95b9812cee008cbdbcb30cc73531c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join_8cpp_source.html#l00020">20</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6a754a19d10bba45d654c79cfec23d37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join_8cpp_source.html#l00024">24</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1af0448079469f224ea8905c34dc1868"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Glue , typename Iterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">Glue&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a sequence of strings by some glue string between each pair from the sequence. </p>
<p>The sequence in given as a range between two iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">first</td><td>the beginning iterator of the range to join </td></tr>
    <tr><td class="paramname">last</td><td>the ending iterator of the range to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the range with the glue between two strings. </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00030">30</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a96227b0edd6c65800124ba1dac82cf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue character between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>character for glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00057">57</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="affea57c0c1e61aa8c9bc50e1ec2f9fe2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00071">71</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e35ca12bd4564ba470e3bf4f6a91798"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00085">85</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6a69ef70f3271d78ba48f36e9c3ce8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::less_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f0d03bfa1f2fa2cf8f8f4211c1fea03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::less_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00033">33</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab93f801299b061af29c7b9613fea4730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::less_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00049">49</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae3b710ccefae45bf1e1838bdc3785ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::less_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00065">65</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae38d352a065543cf324f52a58bd2b026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt; tlx::make_counting </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method analogous to std::make_shared and std::make_unique. </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00244">244</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a184a6d51738969d70693ff4ab40e40db"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename R , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object pointer. </p>
<p>constructor for wrapping a const class::method with object pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00431">431</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e57fc132415d92776d9eed01ae3442"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename R , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00447">447</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf10f085647ba34ff677aeecba994064"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class C , typename R , typename... A&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00455">455</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2afc1ff7d0b9ea7a6583d0573e36ef7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto tlx::make_function_chain </td>
          <td>(</td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Functor chain maker. Can also be called with a lambda function. </p>

<p>Definition at line <a class="el" href="function__chain_8hpp_source.html#l00169">169</a> of file <a class="el" href="function__chain_8hpp_source.html">function_chain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="add2b32ffd2415899c6a69ccac4d7138f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto tlx::make_function_chain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct and empty function chain. </p>

<p>Definition at line <a class="el" href="function__chain_8hpp_source.html#l00175">175</a> of file <a class="el" href="function__chain_8hpp_source.html">function_chain.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af4f5461dca9e4be26479c56a5500357e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Functor &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto tlx::make_function_stack </td>
          <td>(</td>
          <td class="paramtype">const Functor &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function-style construction of a <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a>. </p>

<p>Definition at line <a class="el" href="function__stack_8hpp_source.html#l00167">167</a> of file <a class="el" href="function__stack_8hpp_source.html">function_stack.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a447e57b368c4ce87381d12d5cf1d8b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tlx::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountingPtr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print pointer </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00257">257</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fde10ed812d3e04d76c839583007973"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::pad </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate or pad string to exactly len characters. </p>

<p>Definition at line <a class="el" href="pad_8cpp_source.html#l00015">15</a> of file <a class="el" href="pad_8cpp_source.html">pad.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15f3b68b2a872a4720a493a1dcdb0ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::parse_hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string as a sequence of hexadecimal pairs. </p>
<p>Converts each pair of hexadecimal digits into a byte of the output string. Throws std::runtime_error() if an unknown letter is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to parse as hex digits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of read bytes </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00131">131</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05df4ec244bd2d205d7b3a703f7a1849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::parse_si_iec_units </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>default_unit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes. </p>
<p>Returns the number of bytes and sets ok = true if the string could be parsed correctly. If no units indicator is given, use def_unit in k/m/g/t/p (powers of ten) or in K/M/G/T/P (power of two). </p>

<p>Definition at line <a class="el" href="parse__si__iec__units_8cpp_source.html#l00017">17</a> of file <a class="el" href="parse__si__iec__units_8cpp_source.html">parse_si_iec_units.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad3af33ea198b337b54631777267f9f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::parse_si_iec_units </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>default_unit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes. </p>
<p>Returns the number of bytes and sets ok = true if the string could be parsed correctly. If no units indicator is given, use def_unit in k/m/g/t/p (powers of ten) or in K/M/G/T/P (power of two). </p>

<p>Definition at line <a class="el" href="parse__si__iec__units_8cpp_source.html#l00088">88</a> of file <a class="el" href="parse__si__iec__units_8cpp_source.html">parse_si_iec_units.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf6441c2f401beebca1b130d5c0ede68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00120">120</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8073d342fc47ecdf76ad838e735aa57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00133">133</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b68830fd24a84d6b89c50a878f6d66a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00147">147</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3a6fe09220e86f19f3451cee1e1e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00161">161</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab9321abff9790139f91aa5f318d3674f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00179">179</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a658c2a3f84c00c1654269b57aa18100c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00194">194</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a377bdd21108edc0fda5a7bda408742a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00209">209</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac4636c5529e88f38fa2322cdb5cd735"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00224">224</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5bfd5af4ef681e5431a9dcc9b2f69fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00021">21</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d874ebb36fd5f67b57ed9181f94765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00032">32</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa42af651055bba02cc39d2d2cfd5ddab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00043">43</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a682065cf1b811ca4ab97ca8198d39c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00054">54</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a694e187e8049eb7dc29ff2b59c5f5566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00068">68</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2e21587d2abcd727530592a5e10eca4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00081">81</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acd35eea795e85b2a1435155d3e655f52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00093">93</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aaf41622c559f40295d6136e2ea527a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00105">105</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92ce4619242b36fd76f3b221ad9e0339"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tlx::round_down_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round down to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00055">55</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a140d25c6b9c0222690efc97f8ad1a824"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tlx::round_down_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round down to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00059">59</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6dbfd1aed990afcb9984118d3ee59530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long tlx::round_down_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round down to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00063">63</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a73d5d20f1d750595eb706751194589e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long tlx::round_down_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round down to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00067">67</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65ad6167d69150c4d17040c640c18f40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long tlx::round_down_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round down to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00071">71</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6738c012851741f46a8f189e99b3069e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long tlx::round_down_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round down to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00075">75</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aece38332dbd324d658d87d90c9a5bf6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tlx::round_up_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round up to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00029">29</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a994588afad02e3d4a1aff864c4e0d352"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tlx::round_up_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round up to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00033">33</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a59f491ae70f43f57cc85744b148a7227"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long tlx::round_up_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round up to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00037">37</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5997db3294cb9bdd4c2171c6dc69d23f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long tlx::round_up_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round up to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00041">41</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f753fbc4a8720d69d6af77b48f9ed14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long tlx::round_up_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round up to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00045">45</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29783a06deb58a4fa231da5f76399b1c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long long tlx::round_up_to_power_of_two </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>does what it says: round up to next power of two </p>

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00049">49</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a165140a3f756701491e3958c9858ea2c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Integral &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Integral tlx::round_up_to_power_of_two_template </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00018">18</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3800f082eca7b380e4191684ff7cfade"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00020">20</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15bde434fa34b9e603a1c053ac7f173a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00028">28</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad14d975dfb31444851d8f5198fc0865c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00036">36</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a555f3c9768d7c087c8f29208fe14e41c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00047">47</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab399920b2f8a655e20dc10436ea5cf79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00056">56</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad33b86a8d73bdc55660409d7c7f54a77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00065">65</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae43e0a4decab660095dbf98fa6151f16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00077">77</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae88597e53210df27ef4d5db668a02fa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt;&amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sep_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00107">107</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aecb9b9c50ad82ec43bbf672f4b4caa4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00147">147</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a48ce983b04c074ca5138564e431d4a7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00155">155</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac0a9fa6574cdc019fa938fb003b12e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00166">166</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a757c5e0dddc69fceec20b6782477c98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00179">179</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3cf4c1cb8940c98d9bc913f2b5bd087e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00192">192</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a359648bf7e9bae0d45615233e24d2c12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; tlx::split_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string by whitespaces into distinct words. </p>
<p>Multiple consecutive whitespaces are considered as one split point. Whitespaces are space, tab, newline and carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split__words_8cpp_source.html#l00015">15</a> of file <a class="el" href="split__words_8cpp_source.html">split_words.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab50650708407ad9fd1dbc6fedc945678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00019">19</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1409976857d6b184bd2ce6df6b367d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00026">26</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4b33a83741bd5977c7769a4be7e43d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00039">39</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27633767ce2c4dc221acd4a331ec5c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00049">49</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dee8d3837365def6ce2290d6e76bd55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::swap </td>
          <td>(</td>
          <td class="paramtype">CountingPtr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CountingPtr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap enclosed object with another counting pointer (no reference counts need change) </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00251">251</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a517528748ca179557fe52d4e962e7859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char tlx::to_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the given character to lower case without any localization. </p>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26b550eadfca772df3e1c2ce3a581b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to lowercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5053e892d19dd4fe230e19928287b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string lowercased </dd></dl>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef29005ad36974008f9c0a364878b855"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char tlx::to_upper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the given character to upper case without any localization. </p>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a742b71bfffe387035f604bad0d1ff4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::to_upper </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to uppercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54387562dddddd389df250cdb15ade00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::to_upper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string uppercased </dd></dl>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc70026a4a1d57a74c7125f959245719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00020">20</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d1eecb0fadc2a1fddf598c7263ea4a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00033">33</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a793ce30c7b3cff3a6111b41b07e883e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00046">46</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a32962b0cd33bfbad1b8b9f84d71171fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00062">62</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa95f062055820fcae0be3c5731217989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00112">112</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2e152d7231dc17cf6bbd32cb0c4fa21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00117">117</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51bb404a33a2f6f95c27a3ee392bc5d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00122">122</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac21eb3ad7a12fc40ddf705915556656c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00129">129</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6ce44f04459898e5b6ca63ae5628c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00086">86</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e285a6834d509909818f1c12303993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00091">91</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9db34075fd2fa8291d5784450c3ff7ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00096">96</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a67f5099884188aee9526e5f7a9aefc4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00103">103</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ec6be6417fecf489c677756087b8599"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::union_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wordsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wordsB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return union of two keyword sets. </p>

<p>Definition at line <a class="el" href="union__words_8cpp_source.html#l00016">16</a> of file <a class="el" href="union__words_8cpp_source.html">union_words.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a63b398e6678264958fb8590e9332bf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::unused </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="unused_8hpp_source.html#l00020">20</a> of file <a class="el" href="unused_8hpp_source.html">unused.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a44a90b0de44f0e1aa17ae215db35f458"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tlx::vexpand </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="vexpand_8hpp_source.html#l00021">21</a> of file <a class="el" href="vexpand_8hpp_source.html">vexpand.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a1c233e7ab713b8f8f77f7149f2bc4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Size, typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tlx::vmap_for_range </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vmap a generic functor (like a generic lambda) for the integers [0,Size). </p>

<p>Definition at line <a class="el" href="vmap__for__range_8hpp_source.html#l00059">59</a> of file <a class="el" href="vmap__for__range_8hpp_source.html">vmap_for_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36807642146dd614b63d26ed6bba9c19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Begin, size_t End, typename Functor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tlx::vmap_for_range </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vmap a generic functor (like a generic lambda) for the integers [Begin,End). </p>

<p>Definition at line <a class="el" href="vmap__for__range_8hpp_source.html#l00066">66</a> of file <a class="el" href="vmap__for__range_8hpp_source.html">vmap_for_range.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af379571cbffcf0273d0203ef53bca2b8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tlx::vmap_foreach </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) for each variadic template argument. </p>

<p>Definition at line <a class="el" href="vmap__foreach_8hpp_source.html#l00048">48</a> of file <a class="el" href="vmap__foreach_8hpp_source.html">vmap_foreach.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a5c01183e4cc91ffbec284e8bd9437e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto tlx::vmap_foreach_with_index </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call a generic functor (like a generic lambda) for each variadic template argument together with its zero-based index. </p>

<p>Definition at line <a class="el" href="vmap__foreach__with__index_8hpp_source.html#l00053">53</a> of file <a class="el" href="vmap__foreach__with__index_8hpp_source.html">vmap_foreach_with_index.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab22e05055aa827de79236f0cb53354d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::word_wrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to wrap a string to 80 columns without split words. </p>
<p>All newlines are kept, new newline characters are inserted only at spaces, hence, words are never split. If words longer than 80 columns occur they are NOT broken. </p>

<p>Definition at line <a class="el" href="word__wrap_8cpp_source.html#l00017">17</a> of file <a class="el" href="word__wrap_8cpp_source.html">word_wrap.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetlx.html">tlx</a></li>
    <li class="footer">Generated on Thu Mar 9 2017 13:20:35 for tlx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>

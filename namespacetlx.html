<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>tlx: tlx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tlx
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacetlx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tlx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtrDefaultDeleter.html">CountingPtrDefaultDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default deleter for <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer.">CountingPtr</a>  <a href="classtlx_1_1CountingPtrDefaultDeleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance smart pointer used as a wrapping reference counting pointer.  <a href="classtlx_1_1CountingPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides reference counting abilities for use with <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer.">CountingPtr</a>.  <a href="classtlx_1_1ReferenceCount.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae38d352a065543cf324f52a58bd2b026"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:ae38d352a065543cf324f52a58bd2b026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae38d352a065543cf324f52a58bd2b026">make_counting</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae38d352a065543cf324f52a58bd2b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">method analogous to std::make_shared and std::make_unique.  <a href="#ae38d352a065543cf324f52a58bd2b026">More...</a><br/></td></tr>
<tr class="separator:ae38d352a065543cf324f52a58bd2b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dee8d3837365def6ce2290d6e76bd55"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a5dee8d3837365def6ce2290d6e76bd55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5dee8d3837365def6ce2290d6e76bd55">swap</a> (<a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A &gt; &amp;a1, <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A &gt; &amp;a2) noexcept</td></tr>
<tr class="memdesc:a5dee8d3837365def6ce2290d6e76bd55"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap enclosed object with another counting pointer (no reference counts need change)  <a href="#a5dee8d3837365def6ce2290d6e76bd55">More...</a><br/></td></tr>
<tr class="separator:a5dee8d3837365def6ce2290d6e76bd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447e57b368c4ce87381d12d5cf1d8b12"><td class="memTemplParams" colspan="2">template&lt;typename A &gt; </td></tr>
<tr class="memitem:a447e57b368c4ce87381d12d5cf1d8b12"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a447e57b368c4ce87381d12d5cf1d8b12">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A &gt; &amp;c)</td></tr>
<tr class="memdesc:a447e57b368c4ce87381d12d5cf1d8b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">print pointer  <a href="#a447e57b368c4ce87381d12d5cf1d8b12">More...</a><br/></td></tr>
<tr class="separator:a447e57b368c4ce87381d12d5cf1d8b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189021baeabfe5b52ca34be6d94499b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4189021baeabfe5b52ca34be6d94499b">die_with_message</a> (const std::string &amp;msg)</td></tr>
<tr class="memdesc:a4189021baeabfe5b52ca34be6d94499b"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a4189021baeabfe5b52ca34be6d94499b">More...</a><br/></td></tr>
<tr class="separator:a4189021baeabfe5b52ca34be6d94499b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4ea5cbffd44f2ec0ce8ed33a4a61f6a0">die_with_message</a> (const char *msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a4ea5cbffd44f2ec0ce8ed33a4a61f6a0">More...</a><br/></td></tr>
<tr class="separator:a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649f5837f3dd844a036e9a56534f4bec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a649f5837f3dd844a036e9a56534f4bec">die_with_message</a> (const std::string &amp;msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:a649f5837f3dd844a036e9a56534f4bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a649f5837f3dd844a036e9a56534f4bec">More...</a><br/></td></tr>
<tr class="separator:a649f5837f3dd844a036e9a56534f4bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a717a659d0a374923911729663882bb4b"><td class="memTemplParams" colspan="2">template&lt;typename TypeA , typename TypeB &gt; </td></tr>
<tr class="memitem:a717a659d0a374923911729663882bb4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a717a659d0a374923911729663882bb4b">die_unequal_compare</a> (TypeA a, TypeB b)</td></tr>
<tr class="memdesc:a717a659d0a374923911729663882bb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb" title="Check that X == Y or die miserably, but output the values of X and Y for better debugging.">die_unequal()</a>  <a href="#a717a659d0a374923911729663882bb4b">More...</a><br/></td></tr>
<tr class="separator:a717a659d0a374923911729663882bb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1550ff16b4ba586596da7f1f471abc"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a7b1550ff16b4ba586596da7f1f471abc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7b1550ff16b4ba586596da7f1f471abc">die_unequal_compare</a> (float a, float b)</td></tr>
<tr class="separator:a7b1550ff16b4ba586596da7f1f471abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8b35ade280b3f91e8139002674d827"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:abe8b35ade280b3f91e8139002674d827"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#abe8b35ade280b3f91e8139002674d827">die_unequal_compare</a> (double a, double b)</td></tr>
<tr class="separator:abe8b35ade280b3f91e8139002674d827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2dd5bc7b975d74e87f79590c14d761f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab2dd5bc7b975d74e87f79590c14d761f">base64_encode</a> (const void *data, size_t size, size_t line_break=0)</td></tr>
<tr class="memdesc:ab2dd5bc7b975d74e87f79590c14d761f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548.  <a href="#ab2dd5bc7b975d74e87f79590c14d761f">More...</a><br/></td></tr>
<tr class="separator:ab2dd5bc7b975d74e87f79590c14d761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8aa4ba3081a5e44addd2a616877d4d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af8aa4ba3081a5e44addd2a616877d4d6">base64_encode</a> (const std::string &amp;str, size_t line_break=0)</td></tr>
<tr class="memdesc:af8aa4ba3081a5e44addd2a616877d4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548.  <a href="#af8aa4ba3081a5e44addd2a616877d4d6">More...</a><br/></td></tr>
<tr class="separator:af8aa4ba3081a5e44addd2a616877d4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81eee6726695191b838c71cfab87775"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac81eee6726695191b838c71cfab87775">base64_decode</a> (const void *data, size_t size, bool strict=true)</td></tr>
<tr class="memdesc:ac81eee6726695191b838c71cfab87775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="#ac81eee6726695191b838c71cfab87775">More...</a><br/></td></tr>
<tr class="separator:ac81eee6726695191b838c71cfab87775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf60ffb92fd69bd1daf92ce2c30ce5d9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acf60ffb92fd69bd1daf92ce2c30ce5d9">base64_decode</a> (const std::string &amp;str, bool strict=true)</td></tr>
<tr class="memdesc:acf60ffb92fd69bd1daf92ce2c30ce5d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="#acf60ffb92fd69bd1daf92ce2c30ce5d9">More...</a><br/></td></tr>
<tr class="separator:acf60ffb92fd69bd1daf92ce2c30ce5d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6733a80c87e8184aa2dfda13f27db213"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6733a80c87e8184aa2dfda13f27db213">ends_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:a6733a80c87e8184aa2dfda13f27db213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#a6733a80c87e8184aa2dfda13f27db213">More...</a><br/></td></tr>
<tr class="separator:a6733a80c87e8184aa2dfda13f27db213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9b803169617726fdcd5067e6077c35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9b9b803169617726fdcd5067e6077c35">ends_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a9b9b803169617726fdcd5067e6077c35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#a9b9b803169617726fdcd5067e6077c35">More...</a><br/></td></tr>
<tr class="separator:a9b9b803169617726fdcd5067e6077c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d016f374292dbdce16a2cf92167132"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad6d016f374292dbdce16a2cf92167132">ends_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ad6d016f374292dbdce16a2cf92167132"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#ad6d016f374292dbdce16a2cf92167132">More...</a><br/></td></tr>
<tr class="separator:ad6d016f374292dbdce16a2cf92167132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee97aa9588a7f1009590df7f7d23da6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9ee97aa9588a7f1009590df7f7d23da6">ends_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a9ee97aa9588a7f1009590df7f7d23da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#a9ee97aa9588a7f1009590df7f7d23da6">More...</a><br/></td></tr>
<tr class="separator:a9ee97aa9588a7f1009590df7f7d23da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1745dfeabacc1acb2d27abbcf553f844"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1745dfeabacc1acb2d27abbcf553f844">hexdump</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:a1745dfeabacc1acb2d27abbcf553f844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="#a1745dfeabacc1acb2d27abbcf553f844">More...</a><br/></td></tr>
<tr class="separator:a1745dfeabacc1acb2d27abbcf553f844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bec662b890f0da83582e7df6e3c55bf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3bec662b890f0da83582e7df6e3c55bf">hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a3bec662b890f0da83582e7df6e3c55bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="#a3bec662b890f0da83582e7df6e3c55bf">More...</a><br/></td></tr>
<tr class="separator:a3bec662b890f0da83582e7df6e3c55bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cfe26c3965f170d5367f8132ca9d4d6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6cfe26c3965f170d5367f8132ca9d4d6">hexdump</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:a6cfe26c3965f170d5367f8132ca9d4d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of uppercase hexadecimal pairs.  <a href="#a6cfe26c3965f170d5367f8132ca9d4d6">More...</a><br/></td></tr>
<tr class="separator:a6cfe26c3965f170d5367f8132ca9d4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adab45f7bc3142c72619094a9d77069f1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#adab45f7bc3142c72619094a9d77069f1">hexdump</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:adab45f7bc3142c72619094a9d77069f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs.  <a href="#adab45f7bc3142c72619094a9d77069f1">More...</a><br/></td></tr>
<tr class="separator:adab45f7bc3142c72619094a9d77069f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43ee9db15046fbe68445eaec4e5c163"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae43ee9db15046fbe68445eaec4e5c163">hexdump_sourcecode</a> (const std::string &amp;str, const std::string &amp;var_name=&quot;name&quot;)</td></tr>
<tr class="memdesc:ae43ee9db15046fbe68445eaec4e5c163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string into a C source code snippet.  <a href="#ae43ee9db15046fbe68445eaec4e5c163">More...</a><br/></td></tr>
<tr class="separator:ae43ee9db15046fbe68445eaec4e5c163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e23f2e36a532089a7b49e0c593cbe26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3e23f2e36a532089a7b49e0c593cbe26">hexdump_lc</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:a3e23f2e36a532089a7b49e0c593cbe26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="#a3e23f2e36a532089a7b49e0c593cbe26">More...</a><br/></td></tr>
<tr class="separator:a3e23f2e36a532089a7b49e0c593cbe26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b479ab381ff2e7de94b87708f342c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a78b479ab381ff2e7de94b87708f342c1">hexdump_lc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a78b479ab381ff2e7de94b87708f342c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="#a78b479ab381ff2e7de94b87708f342c1">More...</a><br/></td></tr>
<tr class="separator:a78b479ab381ff2e7de94b87708f342c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ef6db6f00972ce269a6205002895b2"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a81ef6db6f00972ce269a6205002895b2">hexdump_lc</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:a81ef6db6f00972ce269a6205002895b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of lowercase hexadecimal pairs.  <a href="#a81ef6db6f00972ce269a6205002895b2">More...</a><br/></td></tr>
<tr class="separator:a81ef6db6f00972ce269a6205002895b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f65ffd0e8ea4503a9c9a5b681468722"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a0f65ffd0e8ea4503a9c9a5b681468722">hexdump_lc</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:a0f65ffd0e8ea4503a9c9a5b681468722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs.  <a href="#a0f65ffd0e8ea4503a9c9a5b681468722">More...</a><br/></td></tr>
<tr class="separator:a0f65ffd0e8ea4503a9c9a5b681468722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f3b68b2a872a4720a493a1dcdb0ae7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a15f3b68b2a872a4720a493a1dcdb0ae7">parse_hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a15f3b68b2a872a4720a493a1dcdb0ae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string as a sequence of hexadecimal pairs.  <a href="#a15f3b68b2a872a4720a493a1dcdb0ae7">More...</a><br/></td></tr>
<tr class="separator:a15f3b68b2a872a4720a493a1dcdb0ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a485134f5e618b846abb630d44ec6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ae2a485134f5e618b846abb630d44ec6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae2a485134f5e618b846abb630d44ec6f">hexdump_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:ae2a485134f5e618b846abb630d44ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of uppercase hexadecimal pairs.  <a href="#ae2a485134f5e618b846abb630d44ec6f">More...</a><br/></td></tr>
<tr class="separator:ae2a485134f5e618b846abb630d44ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a0b2f444830d8f7b1b0eaf93b5f514bf7">hexdump_lc_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of lowercase hexadecimal pairs.  <a href="#a0b2f444830d8f7b1b0eaf93b5f514bf7">More...</a><br/></td></tr>
<tr class="separator:a0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5bfd5af4ef681e5431a9dcc9b2f69fe"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab5bfd5af4ef681e5431a9dcc9b2f69fe">replace_first</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ab5bfd5af4ef681e5431a9dcc9b2f69fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ab5bfd5af4ef681e5431a9dcc9b2f69fe">More...</a><br/></td></tr>
<tr class="separator:ab5bfd5af4ef681e5431a9dcc9b2f69fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d874ebb36fd5f67b57ed9181f94765"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad5d874ebb36fd5f67b57ed9181f94765">replace_first</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ad5d874ebb36fd5f67b57ed9181f94765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ad5d874ebb36fd5f67b57ed9181f94765">More...</a><br/></td></tr>
<tr class="separator:ad5d874ebb36fd5f67b57ed9181f94765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42af651055bba02cc39d2d2cfd5ddab"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa42af651055bba02cc39d2d2cfd5ddab">replace_first</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:aa42af651055bba02cc39d2d2cfd5ddab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#aa42af651055bba02cc39d2d2cfd5ddab">More...</a><br/></td></tr>
<tr class="separator:aa42af651055bba02cc39d2d2cfd5ddab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682065cf1b811ca4ab97ca8198d39c5d"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a682065cf1b811ca4ab97ca8198d39c5d">replace_first</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:a682065cf1b811ca4ab97ca8198d39c5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#a682065cf1b811ca4ab97ca8198d39c5d">More...</a><br/></td></tr>
<tr class="separator:a682065cf1b811ca4ab97ca8198d39c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a075574532eb9463ee7a7c1083bff4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab6a075574532eb9463ee7a7c1083bff4">replace_first_copy</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ab6a075574532eb9463ee7a7c1083bff4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ab6a075574532eb9463ee7a7c1083bff4">More...</a><br/></td></tr>
<tr class="separator:ab6a075574532eb9463ee7a7c1083bff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272c6eb92b94d0e4d9e6e600f3c2b810"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a272c6eb92b94d0e4d9e6e600f3c2b810">replace_first_copy</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:a272c6eb92b94d0e4d9e6e600f3c2b810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#a272c6eb92b94d0e4d9e6e600f3c2b810">More...</a><br/></td></tr>
<tr class="separator:a272c6eb92b94d0e4d9e6e600f3c2b810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3a274f73b5c43ab4813a26f6cafeaf8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac3a274f73b5c43ab4813a26f6cafeaf8">replace_first_copy</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ac3a274f73b5c43ab4813a26f6cafeaf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ac3a274f73b5c43ab4813a26f6cafeaf8">More...</a><br/></td></tr>
<tr class="separator:ac3a274f73b5c43ab4813a26f6cafeaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d2d19179f41539ba5ae36f0e47aa95"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad7d2d19179f41539ba5ae36f0e47aa95">replace_first_copy</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ad7d2d19179f41539ba5ae36f0e47aa95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ad7d2d19179f41539ba5ae36f0e47aa95">More...</a><br/></td></tr>
<tr class="separator:ad7d2d19179f41539ba5ae36f0e47aa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6441c2f401beebca1b130d5c0ede68"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#adf6441c2f401beebca1b130d5c0ede68">replace_all</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:adf6441c2f401beebca1b130d5c0ede68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#adf6441c2f401beebca1b130d5c0ede68">More...</a><br/></td></tr>
<tr class="separator:adf6441c2f401beebca1b130d5c0ede68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8073d342fc47ecdf76ad838e735aa57"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac8073d342fc47ecdf76ad838e735aa57">replace_all</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ac8073d342fc47ecdf76ad838e735aa57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ac8073d342fc47ecdf76ad838e735aa57">More...</a><br/></td></tr>
<tr class="separator:ac8073d342fc47ecdf76ad838e735aa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b68830fd24a84d6b89c50a878f6d66a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5b68830fd24a84d6b89c50a878f6d66a">replace_all</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:a5b68830fd24a84d6b89c50a878f6d66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a5b68830fd24a84d6b89c50a878f6d66a">More...</a><br/></td></tr>
<tr class="separator:a5b68830fd24a84d6b89c50a878f6d66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3a6fe09220e86f19f3451cee1e1e21"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7c3a6fe09220e86f19f3451cee1e1e21">replace_all</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:a7c3a6fe09220e86f19f3451cee1e1e21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a7c3a6fe09220e86f19f3451cee1e1e21">More...</a><br/></td></tr>
<tr class="separator:a7c3a6fe09220e86f19f3451cee1e1e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1106409ef560622632d6d4af24eafd"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afc1106409ef560622632d6d4af24eafd">replace_all_copy</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:afc1106409ef560622632d6d4af24eafd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#afc1106409ef560622632d6d4af24eafd">More...</a><br/></td></tr>
<tr class="separator:afc1106409ef560622632d6d4af24eafd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0dbe0d12e500d44689b53b540fce13"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6c0dbe0d12e500d44689b53b540fce13">replace_all_copy</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:a6c0dbe0d12e500d44689b53b540fce13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a6c0dbe0d12e500d44689b53b540fce13">More...</a><br/></td></tr>
<tr class="separator:a6c0dbe0d12e500d44689b53b540fce13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0873c4e8650f8b74a39d5b9f782a29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aac0873c4e8650f8b74a39d5b9f782a29">replace_all_copy</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:aac0873c4e8650f8b74a39d5b9f782a29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#aac0873c4e8650f8b74a39d5b9f782a29">More...</a><br/></td></tr>
<tr class="separator:aac0873c4e8650f8b74a39d5b9f782a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3255d8b8d11fae6478476d98d0a3f083"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3255d8b8d11fae6478476d98d0a3f083">replace_all_copy</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:a3255d8b8d11fae6478476d98d0a3f083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#a3255d8b8d11fae6478476d98d0a3f083">More...</a><br/></td></tr>
<tr class="separator:a3255d8b8d11fae6478476d98d0a3f083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50650708407ad9fd1dbc6fedc945678"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab50650708407ad9fd1dbc6fedc945678">starts_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ab50650708407ad9fd1dbc6fedc945678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#ab50650708407ad9fd1dbc6fedc945678">More...</a><br/></td></tr>
<tr class="separator:ab50650708407ad9fd1dbc6fedc945678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409976857d6b184bd2ce6df6b367d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1409976857d6b184bd2ce6df6b367d6e">starts_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a1409976857d6b184bd2ce6df6b367d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#a1409976857d6b184bd2ce6df6b367d6e">More...</a><br/></td></tr>
<tr class="separator:a1409976857d6b184bd2ce6df6b367d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b33a83741bd5977c7769a4be7e43d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab4b33a83741bd5977c7769a4be7e43d0">starts_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ab4b33a83741bd5977c7769a4be7e43d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#ab4b33a83741bd5977c7769a4be7e43d0">More...</a><br/></td></tr>
<tr class="separator:ab4b33a83741bd5977c7769a4be7e43d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27633767ce2c4dc221acd4a331ec5c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a27633767ce2c4dc221acd4a331ec5c47">starts_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:a27633767ce2c4dc221acd4a331ec5c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#a27633767ce2c4dc221acd4a331ec5c47">More...</a><br/></td></tr>
<tr class="separator:a27633767ce2c4dc221acd4a331ec5c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787d0150be5764f89d1975a81c7fa497"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a787d0150be5764f89d1975a81c7fa497">to_lower</a> (char ch)</td></tr>
<tr class="separator:a787d0150be5764f89d1975a81c7fa497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b550eadfca772df3e1c2ce3a581b02"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a26b550eadfca772df3e1c2ce3a581b02">to_lower</a> (std::string *str)</td></tr>
<tr class="memdesc:a26b550eadfca772df3e1c2ce3a581b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to lowercase and returns a reference to it.  <a href="#a26b550eadfca772df3e1c2ce3a581b02">More...</a><br/></td></tr>
<tr class="separator:a26b550eadfca772df3e1c2ce3a581b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5053e892d19dd4fe230e19928287b89"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad5053e892d19dd4fe230e19928287b89">to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ad5053e892d19dd4fe230e19928287b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to lowercase.  <a href="#ad5053e892d19dd4fe230e19928287b89">More...</a><br/></td></tr>
<tr class="separator:ad5053e892d19dd4fe230e19928287b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f82d485f189390810595e3bd7b3af1"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac6f82d485f189390810595e3bd7b3af1">to_upper</a> (char ch)</td></tr>
<tr class="separator:ac6f82d485f189390810595e3bd7b3af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742b71bfffe387035f604bad0d1ff4aa"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a742b71bfffe387035f604bad0d1ff4aa">to_upper</a> (std::string *str)</td></tr>
<tr class="memdesc:a742b71bfffe387035f604bad0d1ff4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to uppercase and returns a reference to it.  <a href="#a742b71bfffe387035f604bad0d1ff4aa">More...</a><br/></td></tr>
<tr class="separator:a742b71bfffe387035f604bad0d1ff4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54387562dddddd389df250cdb15ade00"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a54387562dddddd389df250cdb15ade00">to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:a54387562dddddd389df250cdb15ade00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to uppercase.  <a href="#a54387562dddddd389df250cdb15ade00">More...</a><br/></td></tr>
<tr class="separator:a54387562dddddd389df250cdb15ade00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc70026a4a1d57a74c7125f959245719"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afc70026a4a1d57a74c7125f959245719">trim</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:afc70026a4a1d57a74c7125f959245719"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#afc70026a4a1d57a74c7125f959245719">More...</a><br/></td></tr>
<tr class="separator:afc70026a4a1d57a74c7125f959245719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d1eecb0fadc2a1fddf598c7263ea4a9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3d1eecb0fadc2a1fddf598c7263ea4a9">trim</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a3d1eecb0fadc2a1fddf598c7263ea4a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#a3d1eecb0fadc2a1fddf598c7263ea4a9">More...</a><br/></td></tr>
<tr class="separator:a3d1eecb0fadc2a1fddf598c7263ea4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27485b91b71426bf179fc93dc6638caa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a27485b91b71426bf179fc93dc6638caa">trim_copy</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:a27485b91b71426bf179fc93dc6638caa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#a27485b91b71426bf179fc93dc6638caa">More...</a><br/></td></tr>
<tr class="separator:a27485b91b71426bf179fc93dc6638caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa82fea497cc10c03c466076a2194e0a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa82fea497cc10c03c466076a2194e0a1">trim_copy</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:aa82fea497cc10c03c466076a2194e0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#aa82fea497cc10c03c466076a2194e0a1">More...</a><br/></td></tr>
<tr class="separator:aa82fea497cc10c03c466076a2194e0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ce44f04459898e5b6ca63ae5628c1f"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa6ce44f04459898e5b6ca63ae5628c1f">trim_right</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:aa6ce44f04459898e5b6ca63ae5628c1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="#aa6ce44f04459898e5b6ca63ae5628c1f">More...</a><br/></td></tr>
<tr class="separator:aa6ce44f04459898e5b6ca63ae5628c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e285a6834d509909818f1c12303993"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e285a6834d509909818f1c12303993">trim_right</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:a36e285a6834d509909818f1c12303993"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="#a36e285a6834d509909818f1c12303993">More...</a><br/></td></tr>
<tr class="separator:a36e285a6834d509909818f1c12303993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae900a3a492d3a21e07d3c75968b91d99"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae900a3a492d3a21e07d3c75968b91d99">trim_right_copy</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:ae900a3a492d3a21e07d3c75968b91d99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="#ae900a3a492d3a21e07d3c75968b91d99">More...</a><br/></td></tr>
<tr class="separator:ae900a3a492d3a21e07d3c75968b91d99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe2789ae52bf8db823326f1d796268f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aabe2789ae52bf8db823326f1d796268f">trim_right_copy</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:aabe2789ae52bf8db823326f1d796268f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="#aabe2789ae52bf8db823326f1d796268f">More...</a><br/></td></tr>
<tr class="separator:aabe2789ae52bf8db823326f1d796268f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95f062055820fcae0be3c5731217989"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa95f062055820fcae0be3c5731217989">trim_left</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:aa95f062055820fcae0be3c5731217989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="#aa95f062055820fcae0be3c5731217989">More...</a><br/></td></tr>
<tr class="separator:aa95f062055820fcae0be3c5731217989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e152d7231dc17cf6bbd32cb0c4fa21"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad2e152d7231dc17cf6bbd32cb0c4fa21">trim_left</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ad2e152d7231dc17cf6bbd32cb0c4fa21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="#ad2e152d7231dc17cf6bbd32cb0c4fa21">More...</a><br/></td></tr>
<tr class="separator:ad2e152d7231dc17cf6bbd32cb0c4fa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af162732e350f2283a44a57b55437e707"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#af162732e350f2283a44a57b55437e707">trim_left_copy</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:af162732e350f2283a44a57b55437e707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="#af162732e350f2283a44a57b55437e707">More...</a><br/></td></tr>
<tr class="separator:af162732e350f2283a44a57b55437e707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c76019a58838bfeab00f36932db4e0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad5c76019a58838bfeab00f36932db4e0">trim_left_copy</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ad5c76019a58838bfeab00f36932db4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="#ad5c76019a58838bfeab00f36932db4e0">More...</a><br/></td></tr>
<tr class="separator:ad5c76019a58838bfeab00f36932db4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac81eee6726695191b838c71cfab87775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to decode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to decode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00108">108</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="acf60ffb92fd69bd1daf92ce2c30ce5d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00204">204</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab2dd5bc7b975d74e87f79590c14d761f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to encode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00025">25</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af8aa4ba3081a5e44addd2a616877d4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::base64_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00102">102</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a717a659d0a374923911729663882bb4b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TypeA , typename TypeB &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_unequal_compare </td>
          <td>(</td>
          <td class="paramtype">TypeA&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeB&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb" title="Check that X == Y or die miserably, but output the values of X and Y for better debugging.">die_unequal()</a> </p>

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00074">74</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b1550ff16b4ba586596da7f1f471abc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_unequal_compare </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00079">79</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe8b35ade280b3f91e8139002674d827"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_unequal_compare </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00085">85</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4189021baeabfe5b52ca34be6d94499b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00018">18</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ea5cbffd44f2ec0ce8ed33a4a61f6a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::die_with_message </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00023">23</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a649f5837f3dd844a036e9a56534f4bec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00029">29</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6733a80c87e8184aa2dfda13f27db213"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00018">18</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9b9b803169617726fdcd5067e6077c35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00025">25</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad6d016f374292dbdce16a2cf92167132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00039">39</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ee97aa9588a7f1009590df7f7d23da6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00049">49</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1745dfeabacc1acb2d27abbcf553f844"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00021">21</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3bec662b890f0da83582e7df6e3c55bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00042">42</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6cfe26c3965f170d5367f8132ca9d4d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00046">46</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adab45f7bc3142c72619094a9d77069f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00050">50</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e23f2e36a532089a7b49e0c593cbe26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00095">95</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a78b479ab381ff2e7de94b87708f342c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00116">116</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a81ef6db6f00972ce269a6205002895b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00120">120</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f65ffd0e8ea4503a9c9a5b681468722"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00124">124</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0b2f444830d8f7b1b0eaf93b5f514bf7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8hpp_source.html#l00104">104</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae43ee9db15046fbe68445eaec4e5c163"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_sourcecode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em> = <code>&quot;name&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string into a C source code snippet. </p>
<p>The snippet defines an array of const uint8_t* holding the data of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to output as C source array </td></tr>
    <tr><td class="paramname">var_name</td><td>name of the array variable in the outputted code snippet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding C source snippet </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00054">54</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2a485134f5e618b846abb630d44ec6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8hpp_source.html#l00046">46</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae38d352a065543cf324f52a58bd2b026"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Type , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt; tlx::make_counting </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method analogous to std::make_shared and std::make_unique. </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00240">240</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a447e57b368c4ce87381d12d5cf1d8b12"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tlx::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountingPtr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print pointer </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00253">253</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a15f3b68b2a872a4720a493a1dcdb0ae7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::parse_hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string as a sequence of hexadecimal pairs. </p>
<p>Converts each pair of hexadecimal digits into a byte of the output string. Throws std::runtime_error() if an unknown letter is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to parse as hex digits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of read bytes </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00131">131</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="adf6441c2f401beebca1b130d5c0ede68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00120">120</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac8073d342fc47ecdf76ad838e735aa57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00133">133</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b68830fd24a84d6b89c50a878f6d66a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00147">147</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3a6fe09220e86f19f3451cee1e1e21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00161">161</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc1106409ef560622632d6d4af24eafd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00179">179</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6c0dbe0d12e500d44689b53b540fce13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00194">194</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aac0873c4e8650f8b74a39d5b9f782a29"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00209">209</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3255d8b8d11fae6478476d98d0a3f083"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_all_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00224">224</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab5bfd5af4ef681e5431a9dcc9b2f69fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00021">21</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5d874ebb36fd5f67b57ed9181f94765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00032">32</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa42af651055bba02cc39d2d2cfd5ddab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00043">43</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a682065cf1b811ca4ab97ca8198d39c5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00054">54</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab6a075574532eb9463ee7a7c1083bff4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00068">68</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a272c6eb92b94d0e4d9e6e600f3c2b810"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00081">81</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3a274f73b5c43ab4813a26f6cafeaf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00093">93</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad7d2d19179f41539ba5ae36f0e47aa95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::replace_first_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00105">105</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab50650708407ad9fd1dbc6fedc945678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00017">17</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1409976857d6b184bd2ce6df6b367d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00024">24</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4b33a83741bd5977c7769a4be7e43d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00037">37</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27633767ce2c4dc221acd4a331ec5c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00047">47</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dee8d3837365def6ce2290d6e76bd55"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::swap </td>
          <td>(</td>
          <td class="paramtype">CountingPtr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CountingPtr&lt; A &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap enclosed object with another counting pointer (no reference counts need change) </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00247">247</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a787d0150be5764f89d1975a81c7fa497"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char tlx::to_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a26b550eadfca772df3e1c2ce3a581b02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to lowercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5053e892d19dd4fe230e19928287b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string lowercased </dd></dl>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6f82d485f189390810595e3bd7b3af1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static char tlx::to_upper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a742b71bfffe387035f604bad0d1ff4aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::to_upper </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to uppercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a54387562dddddd389df250cdb15ade00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::to_upper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string uppercased </dd></dl>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="afc70026a4a1d57a74c7125f959245719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00020">20</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3d1eecb0fadc2a1fddf598c7263ea4a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00033">33</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27485b91b71426bf179fc93dc6638caa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00046">46</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa82fea497cc10c03c466076a2194e0a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00062">62</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa95f062055820fcae0be3c5731217989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00112">112</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2e152d7231dc17cf6bbd32cb0c4fa21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00117">117</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="af162732e350f2283a44a57b55437e707"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_left_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00122">122</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad5c76019a58838bfeab00f36932db4e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_left_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00129">129</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa6ce44f04459898e5b6ca63ae5628c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00086">86</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e285a6834d509909818f1c12303993"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; tlx::trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00091">91</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae900a3a492d3a21e07d3c75968b91d99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_right_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00096">96</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aabe2789ae52bf8db823326f1d796268f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::trim_right_copy </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00103">103</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetlx.html">tlx</a></li>
    <li class="footer">Generated on Mon Feb 20 2017 17:13:45 for tlx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3.1"/>
<title>tlx: tlx::Delegate&lt; R(A...), Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">tlx
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tlx::Delegate&lt; R(A...), Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This is a faster replacement than std::function.  
 <a href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsConstMemberPair.html">IsConstMemberPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template for const class::function selector  <a href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsConstMemberPair.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsConstMemberPair_3_01ConstMemberPair_3_01C_01_4_01_4.html">IsConstMemberPair&lt; ConstMemberPair&lt; C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for const class::function selector  <a href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsConstMemberPair_3_01ConstMemberPair_3_01C_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsMemberPair.html">IsMemberPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template for class::function selector  <a href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsMemberPair.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsMemberPair_3_01MemberPair_3_01C_01_4_01_4.html">IsMemberPair&lt; MemberPair&lt; C &gt; &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">specialization for class::function selector  <a href="structtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4_1_1IsMemberPair_3_01MemberPair_3_01C_01_4_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add200ef575c3248867cd1401f46c58ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#add200ef575c3248867cd1401f46c58ca">Delegate</a> ()=default</td></tr>
<tr class="memdesc:add200ef575c3248867cd1401f46c58ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">default constructor  <a href="#add200ef575c3248867cd1401f46c58ca">More...</a><br/></td></tr>
<tr class="separator:add200ef575c3248867cd1401f46c58ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3784d3835a41c98b78f00d198d789088"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a3784d3835a41c98b78f00d198d789088">Delegate</a> (const <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;)=default</td></tr>
<tr class="memdesc:a3784d3835a41c98b78f00d198d789088"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#a3784d3835a41c98b78f00d198d789088">More...</a><br/></td></tr>
<tr class="separator:a3784d3835a41c98b78f00d198d789088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333a5364c9cbc7d883886c60a41c9a4c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a333a5364c9cbc7d883886c60a41c9a4c">Delegate</a> (<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:a333a5364c9cbc7d883886c60a41c9a4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="#a333a5364c9cbc7d883886c60a41c9a4c">More...</a><br/></td></tr>
<tr class="separator:a333a5364c9cbc7d883886c60a41c9a4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46981203896741c954e49f33c4c81312"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a46981203896741c954e49f33c4c81312">operator=</a> (const <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;)=default</td></tr>
<tr class="memdesc:a46981203896741c954e49f33c4c81312"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment operator  <a href="#a46981203896741c954e49f33c4c81312">More...</a><br/></td></tr>
<tr class="separator:a46981203896741c954e49f33c4c81312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb02babb1c48d1427c6e4d557c747e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#aedb02babb1c48d1427c6e4d557c747e5">operator=</a> (<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;&amp;)=default</td></tr>
<tr class="memdesc:aedb02babb1c48d1427c6e4d557c747e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment operator  <a href="#aedb02babb1c48d1427c6e4d557c747e5">More...</a><br/></td></tr>
<tr class="separator:aedb02babb1c48d1427c6e4d557c747e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Miscellaneous</div></td></tr>
<tr class="memitem:a5331f78f7a6f13d5bb626a0439728165"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a5331f78f7a6f13d5bb626a0439728165">reset</a> ()</td></tr>
<tr class="memdesc:a5331f78f7a6f13d5bb626a0439728165"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset delegate to invalid.  <a href="#a5331f78f7a6f13d5bb626a0439728165">More...</a><br/></td></tr>
<tr class="separator:a5331f78f7a6f13d5bb626a0439728165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925d6d0cf2d292b88052cc6f953b526e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a925d6d0cf2d292b88052cc6f953b526e">reset_caller</a> () noexcept</td></tr>
<tr class="separator:a925d6d0cf2d292b88052cc6f953b526e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a766dd3c8ee601e09fc48702df2e40e15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a766dd3c8ee601e09fc48702df2e40e15">swap</a> (<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a766dd3c8ee601e09fc48702df2e40e15"><td class="mdescLeft">&#160;</td><td class="mdescRight">swap delegates  <a href="#a766dd3c8ee601e09fc48702df2e40e15">More...</a><br/></td></tr>
<tr class="separator:a766dd3c8ee601e09fc48702df2e40e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db8b3daa69634cac3bd6553033ec725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a7db8b3daa69634cac3bd6553033ec725">operator==</a> (<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a7db8b3daa69634cac3bd6553033ec725"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare delegate with another  <a href="#a7db8b3daa69634cac3bd6553033ec725">More...</a><br/></td></tr>
<tr class="separator:a7db8b3daa69634cac3bd6553033ec725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ab667d492bdd5c02c4e56d120a49346"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a9ab667d492bdd5c02c4e56d120a49346">operator!=</a> (<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a9ab667d492bdd5c02c4e56d120a49346"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare delegate with another  <a href="#a9ab667d492bdd5c02c4e56d120a49346">More...</a><br/></td></tr>
<tr class="separator:a9ab667d492bdd5c02c4e56d120a49346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4acfaa9b40f3345317cd8db01aa43938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a4acfaa9b40f3345317cd8db01aa43938">operator&lt;</a> (<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> const &amp;rhs) const noexcept</td></tr>
<tr class="memdesc:a4acfaa9b40f3345317cd8db01aa43938"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare delegate with another  <a href="#a4acfaa9b40f3345317cd8db01aa43938">More...</a><br/></td></tr>
<tr class="separator:a4acfaa9b40f3345317cd8db01aa43938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b9b8ef289dcf21aa1c712b6b75ec86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a23b9b8ef289dcf21aa1c712b6b75ec86">operator==</a> (std::nullptr_t const) const noexcept</td></tr>
<tr class="memdesc:a23b9b8ef289dcf21aa1c712b6b75ec86"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare delegate with another  <a href="#a23b9b8ef289dcf21aa1c712b6b75ec86">More...</a><br/></td></tr>
<tr class="separator:a23b9b8ef289dcf21aa1c712b6b75ec86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2affd6e5d62297181a23bee1a1f01bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#af2affd6e5d62297181a23bee1a1f01bb">operator!=</a> (std::nullptr_t const) const noexcept</td></tr>
<tr class="memdesc:af2affd6e5d62297181a23bee1a1f01bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">compare delegate with another  <a href="#af2affd6e5d62297181a23bee1a1f01bb">More...</a><br/></td></tr>
<tr class="separator:af2affd6e5d62297181a23bee1a1f01bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80342ab2c1f5ce8c822b1d54c5b8081d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a80342ab2c1f5ce8c822b1d54c5b8081d">operator bool</a> () const noexcept</td></tr>
<tr class="memdesc:a80342ab2c1f5ce8c822b1d54c5b8081d"><td class="mdescLeft">&#160;</td><td class="mdescRight">explicit conversion to bool -&gt; valid or invalid.  <a href="#a80342ab2c1f5ce8c822b1d54c5b8081d">More...</a><br/></td></tr>
<tr class="separator:a80342ab2c1f5ce8c822b1d54c5b8081d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f823769e50aa2ce2f441cd9fe54c7a7"><td class="memItemLeft" align="right" valign="top">R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a9f823769e50aa2ce2f441cd9fe54c7a7">operator()</a> (A...args) const </td></tr>
<tr class="memdesc:a9f823769e50aa2ce2f441cd9fe54c7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">most important method: call.  <a href="#a9f823769e50aa2ce2f441cd9fe54c7a7">More...</a><br/></td></tr>
<tr class="separator:a9f823769e50aa2ce2f441cd9fe54c7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Immediate Function Calls</div></td></tr>
<tr class="memitem:a053789813b2961c8443f7fbd5a9233ec"><td class="memTemplParams" colspan="2">template&lt;R(*)(A...) Function&gt; </td></tr>
<tr class="memitem:a053789813b2961c8443f7fbd5a9233ec"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a053789813b2961c8443f7fbd5a9233ec">make</a> () noexcept</td></tr>
<tr class="memdesc:a053789813b2961c8443f7fbd5a9233ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from an immediate function with no object or pointer.  <a href="#a053789813b2961c8443f7fbd5a9233ec">More...</a><br/></td></tr>
<tr class="separator:a053789813b2961c8443f7fbd5a9233ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Immediate Class::Method Calls with Objects</div></td></tr>
<tr class="memitem:a1d25f11daf45fbf3f031bf0cb59bcb8e"><td class="memTemplParams" colspan="2">template&lt;class C , R(C::*)(A...) Method&gt; </td></tr>
<tr class="memitem:a1d25f11daf45fbf3f031bf0cb59bcb8e"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a1d25f11daf45fbf3f031bf0cb59bcb8e">make</a> (C *const object_ptr) noexcept</td></tr>
<tr class="memdesc:a1d25f11daf45fbf3f031bf0cb59bcb8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction for an immediate class::method with class object  <a href="#a1d25f11daf45fbf3f031bf0cb59bcb8e">More...</a><br/></td></tr>
<tr class="separator:a1d25f11daf45fbf3f031bf0cb59bcb8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe42b118b7affa4cc8d2bb5d5dca7c9"><td class="memTemplParams" colspan="2">template&lt;class C , R(C::*)(A...) const Method&gt; </td></tr>
<tr class="memitem:abfe42b118b7affa4cc8d2bb5d5dca7c9"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#abfe42b118b7affa4cc8d2bb5d5dca7c9">make</a> (C const *const object_ptr) noexcept</td></tr>
<tr class="memdesc:abfe42b118b7affa4cc8d2bb5d5dca7c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction for an immediate class::method with class object  <a href="#abfe42b118b7affa4cc8d2bb5d5dca7c9">More...</a><br/></td></tr>
<tr class="separator:abfe42b118b7affa4cc8d2bb5d5dca7c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490e483d82c74e963483c775dcc70473"><td class="memTemplParams" colspan="2">template&lt;class C , R(C::*)(A...) Method&gt; </td></tr>
<tr class="memitem:a490e483d82c74e963483c775dcc70473"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a490e483d82c74e963483c775dcc70473">make</a> (C &amp;object) noexcept</td></tr>
<tr class="memdesc:a490e483d82c74e963483c775dcc70473"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction for an immediate class::method with class object by reference  <a href="#a490e483d82c74e963483c775dcc70473">More...</a><br/></td></tr>
<tr class="separator:a490e483d82c74e963483c775dcc70473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b3758811387f7ed7218207c01dcdf4"><td class="memTemplParams" colspan="2">template&lt;class C , R(C::*)(A...) const Method&gt; </td></tr>
<tr class="memitem:a38b3758811387f7ed7218207c01dcdf4"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a38b3758811387f7ed7218207c01dcdf4">make</a> (C const &amp;object) noexcept</td></tr>
<tr class="memdesc:a38b3758811387f7ed7218207c01dcdf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction for an immediate class::method with class object by reference  <a href="#a38b3758811387f7ed7218207c01dcdf4">More...</a><br/></td></tr>
<tr class="separator:a38b3758811387f7ed7218207c01dcdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:afd830c57eb7fcb8e956e0f34a2235678"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#afd830c57eb7fcb8e956e0f34a2235678">Caller</a> = R(*)(void *, A &amp;&amp;...)</td></tr>
<tr class="memdesc:afd830c57eb7fcb8e956e0f34a2235678"><td class="mdescLeft">&#160;</td><td class="mdescRight">type of the function caller pointer.  <a href="#afd830c57eb7fcb8e956e0f34a2235678">More...</a><br/></td></tr>
<tr class="separator:afd830c57eb7fcb8e956e0f34a2235678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2979021b55071588f357a82df61ac"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a19f2979021b55071588f357a82df61ac">Deleter</a> = void(*)(void *)</td></tr>
<tr class="separator:a19f2979021b55071588f357a82df61ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aa509b042b8d9f6a7da6345ed4a5025b5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#aa509b042b8d9f6a7da6345ed4a5025b5">Delegate</a> (const <a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#afd830c57eb7fcb8e956e0f34a2235678">Caller</a> &amp;m, void *const obj) noexcept</td></tr>
<tr class="memdesc:aa509b042b8d9f6a7da6345ed4a5025b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">private constructor for plain  <a href="#aa509b042b8d9f6a7da6345ed4a5025b5">More...</a><br/></td></tr>
<tr class="separator:aa509b042b8d9f6a7da6345ed4a5025b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a51cef16f8fed35c859816921d47f6745"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a51cef16f8fed35c859816921d47f6745"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a51cef16f8fed35c859816921d47f6745">store_deleter</a> (void *const ptr)</td></tr>
<tr class="memdesc:a51cef16f8fed35c859816921d47f6745"><td class="mdescLeft">&#160;</td><td class="mdescRight">deleter for stored functor closures  <a href="#a51cef16f8fed35c859816921d47f6745">More...</a><br/></td></tr>
<tr class="separator:a51cef16f8fed35c859816921d47f6745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Callers for simple function and immediate class::method calls.</div></td></tr>
<tr class="memitem:a239cd275f278dc392129db477502ce27"><td class="memTemplParams" colspan="2">template&lt;R(*)(A...) Function&gt; </td></tr>
<tr class="memitem:a239cd275f278dc392129db477502ce27"><td class="memTemplItemLeft" align="right" valign="top">static R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a239cd275f278dc392129db477502ce27">function_caller</a> (void *const, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a239cd275f278dc392129db477502ce27"><td class="mdescLeft">&#160;</td><td class="mdescRight">caller for an immediate function with no object or pointer.  <a href="#a239cd275f278dc392129db477502ce27">More...</a><br/></td></tr>
<tr class="separator:a239cd275f278dc392129db477502ce27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca5de1e22f421e58669f40fa7ae543a"><td class="memItemLeft" align="right" valign="top">static R&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a9ca5de1e22f421e58669f40fa7ae543a">function_ptr_caller</a> (void *const object_ptr, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a9ca5de1e22f421e58669f40fa7ae543a"><td class="mdescLeft">&#160;</td><td class="mdescRight">caller for a plain function pointer.  <a href="#a9ca5de1e22f421e58669f40fa7ae543a">More...</a><br/></td></tr>
<tr class="separator:a9ca5de1e22f421e58669f40fa7ae543a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2378b938c7d9a74f789b9db2a971458"><td class="memTemplParams" colspan="2">template&lt;class C , R(C::*)(A...) method_ptr&gt; </td></tr>
<tr class="memitem:ae2378b938c7d9a74f789b9db2a971458"><td class="memTemplItemLeft" align="right" valign="top">static R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#ae2378b938c7d9a74f789b9db2a971458">method_caller</a> (void *const object_ptr, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae2378b938c7d9a74f789b9db2a971458"><td class="mdescLeft">&#160;</td><td class="mdescRight">function caller for immediate class::method function calls  <a href="#ae2378b938c7d9a74f789b9db2a971458">More...</a><br/></td></tr>
<tr class="separator:ae2378b938c7d9a74f789b9db2a971458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967110ddb3671edab8cf528bf014238f"><td class="memTemplParams" colspan="2">template&lt;class C , R(C::*)(A...) const method_ptr&gt; </td></tr>
<tr class="memitem:a967110ddb3671edab8cf528bf014238f"><td class="memTemplItemLeft" align="right" valign="top">static R&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a967110ddb3671edab8cf528bf014238f">const_method_caller</a> (void *const object_ptr, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a967110ddb3671edab8cf528bf014238f"><td class="mdescLeft">&#160;</td><td class="mdescRight">function caller for immediate const class::method functions calls.  <a href="#a967110ddb3671edab8cf528bf014238f">More...</a><br/></td></tr>
<tr class="separator:a967110ddb3671edab8cf528bf014238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a315107e2bb3923c5e4b31856e50b99b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#afd830c57eb7fcb8e956e0f34a2235678">Caller</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a315107e2bb3923c5e4b31856e50b99b7">caller_</a> = nullptr</td></tr>
<tr class="memdesc:a315107e2bb3923c5e4b31856e50b99b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to function caller which depends on the type in object_ptr_.  <a href="#a315107e2bb3923c5e4b31856e50b99b7">More...</a><br/></td></tr>
<tr class="separator:a315107e2bb3923c5e4b31856e50b99b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aae1265719c7a0dceaea1ac2ca3e709"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a0aae1265719c7a0dceaea1ac2ca3e709">object_ptr_</a> = nullptr</td></tr>
<tr class="memdesc:a0aae1265719c7a0dceaea1ac2ca3e709"><td class="mdescLeft">&#160;</td><td class="mdescRight">pointer to object held by the delegate: for plain function pointers it is the function pointer, for class::methods it is a pointer to the class instance, for functors it is a pointer to the shared_ptr store_ contents.  <a href="#a0aae1265719c7a0dceaea1ac2ca3e709">More...</a><br/></td></tr>
<tr class="separator:a0aae1265719c7a0dceaea1ac2ca3e709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926c0efd4aefa9c441b803cedf3897b0"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a926c0efd4aefa9c441b803cedf3897b0">store_</a></td></tr>
<tr class="memdesc:a926c0efd4aefa9c441b803cedf3897b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">shared_ptr used to contain a memory object containing the callable, like lambdas with closures, or our own wrappers.  <a href="#a926c0efd4aefa9c441b803cedf3897b0">More...</a><br/></td></tr>
<tr class="separator:a926c0efd4aefa9c441b803cedf3897b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Function Pointer Calls</h2></td></tr>
<tr class="memitem:a49aaa9dd08cb591d73809754dfa2fbfd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a49aaa9dd08cb591d73809754dfa2fbfd">Delegate</a> (R(*const function_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:a49aaa9dd08cb591d73809754dfa2fbfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from a plain function pointer with no object.  <a href="#a49aaa9dd08cb591d73809754dfa2fbfd">More...</a><br/></td></tr>
<tr class="separator:a49aaa9dd08cb591d73809754dfa2fbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098f206a18c80dd0a5e94ce8264a5e54"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a098f206a18c80dd0a5e94ce8264a5e54">make</a> (R(*const function_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:a098f206a18c80dd0a5e94ce8264a5e54"><td class="mdescLeft">&#160;</td><td class="mdescRight">construction from a plain function pointer with no object.  <a href="#a098f206a18c80dd0a5e94ce8264a5e54">More...</a><br/></td></tr>
<tr class="separator:a098f206a18c80dd0a5e94ce8264a5e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Lambdas with Captures and Wrapped Class::Method Calls with Objects</h2></td></tr>
<tr class="memitem:ade924d7fcf21f1367f14931d80926197"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = typename std::enable_if&lt;            !std::is_same&lt;Delegate, typename std::decay&lt;T&gt;::type&gt;::value            &gt;::type&gt; </td></tr>
<tr class="memitem:ade924d7fcf21f1367f14931d80926197"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#ade924d7fcf21f1367f14931d80926197">Delegate</a> (T &amp;&amp;f)</td></tr>
<tr class="memdesc:ade924d7fcf21f1367f14931d80926197"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from any functor object T, which may be a lambda with capture or a MemberPair or ConstMemberPair wrapper.  <a href="#ade924d7fcf21f1367f14931d80926197">More...</a><br/></td></tr>
<tr class="separator:ade924d7fcf21f1367f14931d80926197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3ceb2dfea162bd4ed735e22ef77c3f"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a4c3ceb2dfea162bd4ed735e22ef77c3f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a4c3ceb2dfea162bd4ed735e22ef77c3f">Delegate</a> (C *const object_ptr, R(C::*const method_ptr)(A...))</td></tr>
<tr class="memdesc:a4c3ceb2dfea162bd4ed735e22ef77c3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object pointer.  <a href="#a4c3ceb2dfea162bd4ed735e22ef77c3f">More...</a><br/></td></tr>
<tr class="separator:a4c3ceb2dfea162bd4ed735e22ef77c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa133ea0b0c85e92b3ee78389edb947ad"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aa133ea0b0c85e92b3ee78389edb947ad"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#aa133ea0b0c85e92b3ee78389edb947ad">Delegate</a> (C *const object_ptr, R(C::*const method_ptr)(A...) const)</td></tr>
<tr class="memdesc:aa133ea0b0c85e92b3ee78389edb947ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object pointer.  <a href="#aa133ea0b0c85e92b3ee78389edb947ad">More...</a><br/></td></tr>
<tr class="separator:aa133ea0b0c85e92b3ee78389edb947ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833091ed629a417f3c0e813b512ec869"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a833091ed629a417f3c0e813b512ec869"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a833091ed629a417f3c0e813b512ec869">Delegate</a> (C &amp;object, R(C::*const method_ptr)(A...))</td></tr>
<tr class="memdesc:a833091ed629a417f3c0e813b512ec869"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object reference.  <a href="#a833091ed629a417f3c0e813b512ec869">More...</a><br/></td></tr>
<tr class="separator:a833091ed629a417f3c0e813b512ec869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a2c8a81f86aea36a485e079a1435d5"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a64a2c8a81f86aea36a485e079a1435d5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a64a2c8a81f86aea36a485e079a1435d5">Delegate</a> (C const &amp;object, R(C::*const method_ptr)(A...) const)</td></tr>
<tr class="memdesc:a64a2c8a81f86aea36a485e079a1435d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object reference.  <a href="#a64a2c8a81f86aea36a485e079a1435d5">More...</a><br/></td></tr>
<tr class="separator:a64a2c8a81f86aea36a485e079a1435d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942745758cce9c2476416a4c2f6d4e44"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a942745758cce9c2476416a4c2f6d4e44"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a942745758cce9c2476416a4c2f6d4e44">make</a> (T &amp;&amp;f)</td></tr>
<tr class="memdesc:a942745758cce9c2476416a4c2f6d4e44"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor from any functor object T, which may be a lambda with capture or a MemberPair or ConstMemberPair wrapper.  <a href="#a942745758cce9c2476416a4c2f6d4e44">More...</a><br/></td></tr>
<tr class="separator:a942745758cce9c2476416a4c2f6d4e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b3f482e0d77b74cbca533bdf377930"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a53b3f482e0d77b74cbca533bdf377930"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a53b3f482e0d77b74cbca533bdf377930">make</a> (C *const object_ptr, R(C::*const method_ptr)(A...))</td></tr>
<tr class="memdesc:a53b3f482e0d77b74cbca533bdf377930"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object pointer.  <a href="#a53b3f482e0d77b74cbca533bdf377930">More...</a><br/></td></tr>
<tr class="separator:a53b3f482e0d77b74cbca533bdf377930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5609cfb6cfaebe55452f3992311c4a43"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a5609cfb6cfaebe55452f3992311c4a43"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a5609cfb6cfaebe55452f3992311c4a43">make</a> (C const *const object_ptr, R(C::*const method_ptr)(A...) const)</td></tr>
<tr class="memdesc:a5609cfb6cfaebe55452f3992311c4a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object pointer.  <a href="#a5609cfb6cfaebe55452f3992311c4a43">More...</a><br/></td></tr>
<tr class="separator:a5609cfb6cfaebe55452f3992311c4a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09badf26d62655c5931927afb33ff6a0"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a09badf26d62655c5931927afb33ff6a0"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a09badf26d62655c5931927afb33ff6a0">make</a> (C &amp;object, R(C::*const method_ptr)(A...))</td></tr>
<tr class="memdesc:a09badf26d62655c5931927afb33ff6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object reference.  <a href="#a09badf26d62655c5931927afb33ff6a0">More...</a><br/></td></tr>
<tr class="separator:a09badf26d62655c5931927afb33ff6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7f38d29ba8bdcd14ba3797075d0f2"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a90e7f38d29ba8bdcd14ba3797075d0f2"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a90e7f38d29ba8bdcd14ba3797075d0f2">make</a> (C const &amp;object, R(C::*const method_ptr)(A...) const)</td></tr>
<tr class="memdesc:a90e7f38d29ba8bdcd14ba3797075d0f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object reference.  <a href="#a90e7f38d29ba8bdcd14ba3797075d0f2">More...</a><br/></td></tr>
<tr class="separator:a90e7f38d29ba8bdcd14ba3797075d0f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Wrappers for indirect class::method calls.</h2></td></tr>
<tr class="memitem:aa96fc6ba0b5875ebeb387c0cb1c7591a"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:aa96fc6ba0b5875ebeb387c0cb1c7591a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#aa96fc6ba0b5875ebeb387c0cb1c7591a">MemberPair</a> = std::pair&lt; C *const, R(C::*const)(A...)&gt;</td></tr>
<tr class="memdesc:aa96fc6ba0b5875ebeb387c0cb1c7591a"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrappers for indirect class::method calls containing (object, method_ptr)  <a href="#aa96fc6ba0b5875ebeb387c0cb1c7591a">More...</a><br/></td></tr>
<tr class="separator:aa96fc6ba0b5875ebeb387c0cb1c7591a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cc3609906ae8bd3d0647f71c4378f6"><td class="memTemplParams" colspan="2">template&lt;class C &gt; </td></tr>
<tr class="memitem:a02cc3609906ae8bd3d0647f71c4378f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a02cc3609906ae8bd3d0647f71c4378f6">ConstMemberPair</a> = std::pair&lt; C const *const, R(C::*const)(A...) const  &gt;</td></tr>
<tr class="memdesc:a02cc3609906ae8bd3d0647f71c4378f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrappers for indirect const class::method calls containing (object, const method_ptr)  <a href="#a02cc3609906ae8bd3d0647f71c4378f6">More...</a><br/></td></tr>
<tr class="separator:a02cc3609906ae8bd3d0647f71c4378f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20c102498dfb8b61191cec8d3841fd85"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a20c102498dfb8b61191cec8d3841fd85"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if<br class="typebreak"/>
&lt; !(IsMemberPair&lt; T &gt;::value||IsConstMemberPair<br class="typebreak"/>
&lt; T &gt;::value), R &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a20c102498dfb8b61191cec8d3841fd85">functor_caller</a> (void *const object_ptr, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a20c102498dfb8b61191cec8d3841fd85"><td class="mdescLeft">&#160;</td><td class="mdescRight">function caller for functor class.  <a href="#a20c102498dfb8b61191cec8d3841fd85">More...</a><br/></td></tr>
<tr class="separator:a20c102498dfb8b61191cec8d3841fd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e25c549ed7eaa5394fa175ecef903fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e25c549ed7eaa5394fa175ecef903fa"><td class="memTemplItemLeft" align="right" valign="top">static std::enable_if<br class="typebreak"/>
&lt; (IsMemberPair&lt; T &gt;::value||IsConstMemberPair<br class="typebreak"/>
&lt; T &gt;::value), R &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a1e25c549ed7eaa5394fa175ecef903fa">functor_caller</a> (void *const object_ptr, A &amp;&amp;...args)</td></tr>
<tr class="memdesc:a1e25c549ed7eaa5394fa175ecef903fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">function caller for const functor class.  <a href="#a1e25c549ed7eaa5394fa175ecef903fa">More...</a><br/></td></tr>
<tr class="separator:a1e25c549ed7eaa5394fa175ecef903fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename R, typename... A, typename Allocator&gt;<br/>
class tlx::Delegate&lt; R(A...), Allocator &gt;</h3>

<p>This is a faster replacement than std::function. </p>
<p>Besides being faster and doing less allocations when used correctly, we use it in places where move-only lambda captures are necessary. std::function is required by the standard to be copy-constructible, and hence does not allow move-only lambda captures.</p>
<p>A <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> contains a reference to any of the following callable objects:</p>
<ul>
<li>an immediate function (called via one indirection)</li>
<li>a mutable function pointer (copied into the <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>)</li>
<li>an immediate class::method call (called via one indirection)</li>
<li>a functor object (the whole object is copied into the <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>)</li>
</ul>
<p>All callable objects must have the signature ReturnType(Arguments ...). If a callable has this signature, it can be bound to the <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>.</p>
<p>To implement all this the <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> contains one pointer to a "caller stub" function, which depends on the contained object and can be an immediate function call, a pointer to the object associated with the callable, and a memory pointer (managed by shared_ptr) for holding larger callables that need to be copied.</p>
<p>A functor object can be a lambda function with its capture, an internally wrapped mutable class::method class stored as pair&lt;object, method_ptr&gt;, or any other old-school functor object.</p>
<p>Delegates can be constructed similar to std::function. </p>
<div class="fragment"><div class="line"><span class="comment">// in defining the Delegate we decide the ReturnType(Arguments ...) signature</span></div>
<div class="line"><span class="keyword">using</span> MyDelegate = Delegate&lt;int(double)&gt;;</div>
<div class="line"></div>
<div class="line"><span class="comment">// this is a plain function bound to the Delegate as a function pointer</span></div>
<div class="line"><span class="keywordtype">int</span> func(<span class="keywordtype">double</span> a) { <span class="keywordflow">return</span> a + 10; }</div>
<div class="line">MyDelegate d1 = MyDelegate(func);</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>AClass {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keywordtype">int</span> method(<span class="keywordtype">double</span> d) { <span class="keywordflow">return</span> d * d; }</div>
<div class="line">};</div>
<div class="line"></div>
<div class="line">AClass a;</div>
<div class="line"></div>
<div class="line"><span class="comment">// this is class::method bound to the Delegate via indirection, warning: this</span></div>
<div class="line"><span class="comment">// creates a needless allocation, because it is stored as pair&lt;Class,Method&gt;</span></div>
<div class="line">MyDelegate d2 = MyDelegate(a, &amp;AClass::method);</div>
<div class="line"><span class="comment">// same as above</span></div>
<div class="line">MyDelegate d3 = MyDelegate::make(a, &amp;AClass::method);</div>
<div class="line"></div>
<div class="line"><span class="comment">// class::method bound to the Delegate via instantiation of an immediate caller</span></div>
<div class="line"><span class="comment">// to the method AClass::method. this is preferred and does not require any</span></div>
<div class="line"><span class="comment">// memory allocation!</span></div>
<div class="line">MyDelegate d4 = MyDelegate::make&lt;AClass, &amp;AClass::method&gt;(a);</div>
<div class="line"></div>
<div class="line"><span class="comment">// a lambda with capture bound to the Delegate, this always performs a memory</span></div>
<div class="line"><span class="comment">// allocation to copy the capture closure.</span></div>
<div class="line"><span class="keywordtype">double</span> offset = 42.0;</div>
<div class="line">MyDelegate d5 = [&amp;](<span class="keywordtype">double</span> a) { <span class="keywordflow">return</span> a + offset; };</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00091">91</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="afd830c57eb7fcb8e956e0f34a2235678"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#afd830c57eb7fcb8e956e0f34a2235678">Caller</a> =  R (*)(void*, A&amp;&amp; ...)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type of the function caller pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00308">308</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02cc3609906ae8bd3d0647f71c4378f6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a02cc3609906ae8bd3d0647f71c4378f6">ConstMemberPair</a> =  std::pair&lt;C const* const, R(C::* const)(A ...) const&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrappers for indirect const class::method calls containing (object, const method_ptr) </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00384">384</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19f2979021b55071588f357a82df61ac"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#a19f2979021b55071588f357a82df61ac">Deleter</a> =  void (*)(void*)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00310">310</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa96fc6ba0b5875ebeb387c0cb1c7591a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#aa96fc6ba0b5875ebeb387c0cb1c7591a">MemberPair</a> =  std::pair&lt;C* const, R(C::* const)(A ...)&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wrappers for indirect class::method calls containing (object, method_ptr) </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00378">378</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="add200ef575c3248867cd1401f46c58ca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default constructor </p>

</div>
</div>
<a class="anchor" id="a3784d3835a41c98b78f00d198d789088"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a class="anchor" id="a333a5364c9cbc7d883886c60a41c9a4c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>

</div>
</div>
<a class="anchor" id="a49aaa9dd08cb591d73809754dfa2fbfd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">R(*)(A...)&#160;</td>
          <td class="paramname"><em>function_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from a plain function pointer with no object. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00124">124</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade924d7fcf21f1367f14931d80926197"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename  = typename std::enable_if&lt;            !std::is_same&lt;Delegate, typename std::decay&lt;T&gt;::type&gt;::value            &gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from any functor object T, which may be a lambda with capture or a MemberPair or ConstMemberPair wrapper. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00182">182</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c3ceb2dfea162bd4ed735e22ef77c3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00210">210</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa133ea0b0c85e92b3ee78389edb947ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00215">215</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a833091ed629a417f3c0e813b512ec869"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00220">220</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64a2c8a81f86aea36a485e079a1435d5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00225">225</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa509b042b8d9f6a7da6345ed4a5025b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::<a class="el" href="classtlx_1_1Delegate.html">Delegate</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#afd830c57eb7fcb8e956e0f34a2235678">Caller</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>private constructor for plain </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00329">329</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a967110ddb3671edab8cf528bf014238f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C , R(C::*)(A...) const method_ptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::const_method_caller </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function caller for immediate const class::method functions calls. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00364">364</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a239cd275f278dc392129db477502ce27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;R(*)(A...) Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::function_caller </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>const</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>caller for an immediate function with no object or pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00346">346</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ca5de1e22f421e58669f40fa7ae543a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::function_ptr_caller </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>caller for a plain function pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00351">351</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20c102498dfb8b61191cec8d3841fd85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; !(IsMemberPair&lt;T&gt;::value || IsConstMemberPair&lt;T&gt;::value), R &gt;::type <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::functor_caller </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function caller for functor class. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00407">407</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1e25c549ed7eaa5394fa175ecef903fa"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::enable_if&lt; (IsMemberPair&lt;T&gt;::value || IsConstMemberPair&lt;T&gt;::value), R &gt;::type <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::functor_caller </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function caller for const functor class. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00416">416</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a053789813b2961c8443f7fbd5a9233ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;R(*)(A...) Function&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction from an immediate function with no object or pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00114">114</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a098f206a18c80dd0a5e94ce8264a5e54"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">R(*)(A...)&#160;</td>
          <td class="paramname"><em>function_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction from a plain function pointer with no object. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00132">132</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d25f11daf45fbf3f031bf0cb59bcb8e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C , R(C::*)(A...) Method&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction for an immediate class::method with class object </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00143">143</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abfe42b118b7affa4cc8d2bb5d5dca7c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C , R(C::*)(A...) const Method&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C const *const&#160;</td>
          <td class="paramname"><em>object_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction for an immediate class::method with class object </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00149">149</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a490e483d82c74e963483c775dcc70473"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C , R(C::*)(A...) Method&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction for an immediate class::method with class object by reference </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00157">157</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a38b3758811387f7ed7218207c01dcdf4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C , R(C::*)(A...) const Method&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>object</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>construction for an immediate class::method with class object by reference </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00164">164</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a942745758cce9c2476416a4c2f6d4e44"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor from any functor object T, which may be a lambda with capture or a MemberPair or ConstMemberPair wrapper. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00204">204</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a53b3f482e0d77b74cbca533bdf377930"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00230">230</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5609cfb6cfaebe55452f3992311c4a43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C const *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00237">237</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a09badf26d62655c5931927afb33ff6a0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00244">244</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a90e7f38d29ba8bdcd14ba3797075d0f2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classtlx_1_1Delegate.html">Delegate</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::make </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00250">250</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae2378b938c7d9a74f789b9db2a971458"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;class C , R(C::*)(A...) method_ptr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static R <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::method_caller </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">A &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>function caller for immediate class::method function calls </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00357">357</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a80342ab2c1f5ce8c822b1d54c5b8081d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>explicit conversion to bool -&gt; valid or invalid. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00295">295</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9ab667d492bdd5c02c4e56d120a49346"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare delegate with another </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00274">274</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2affd6e5d62297181a23bee1a1f01bb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>const</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare delegate with another </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00290">290</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9f823769e50aa2ce2f441cd9fe54c7a7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">R <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">A...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>most important method: call. </p>
<p>The call is forwarded to the selected function caller. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00299">299</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4acfaa9b40f3345317cd8db01aa43938"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare delegate with another </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00279">279</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46981203896741c954e49f33c4c81312"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&amp; <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment operator </p>

</div>
</div>
<a class="anchor" id="aedb02babb1c48d1427c6e4d557c747e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&amp; <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assignment operator </p>

</div>
</div>
<a class="anchor" id="a7db8b3daa69634cac3bd6553033ec725"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; const &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare delegate with another </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00269">269</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a23b9b8ef289dcf21aa1c712b6b75ec86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">std::nullptr_t&#160;</td>
          <td class="paramname"><em>const</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>compare delegate with another </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00285">285</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5331f78f7a6f13d5bb626a0439728165"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reset delegate to invalid. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00261">261</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a925d6d0cf2d292b88052cc6f953b526e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::reset_caller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00263">263</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a51cef16f8fed35c859816921d47f6745"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::store_deleter </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>deleter for stored functor closures </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00334">334</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a766dd3c8ee601e09fc48702df2e40e15"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...), Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>swap delegates </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00266">266</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a315107e2bb3923c5e4b31856e50b99b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#afd830c57eb7fcb8e956e0f34a2235678">Caller</a> <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::caller_ = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to function caller which depends on the type in object_ptr_. </p>
<p>The caller_ contains a plain pointer to either function_caller, a function_ptr_caller, a method_caller, a const_method_caller, or a functor_caller. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00316">316</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0aae1265719c7a0dceaea1ac2ca3e709"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::object_ptr_ = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>pointer to object held by the delegate: for plain function pointers it is the function pointer, for class::methods it is a pointer to the class instance, for functors it is a pointer to the shared_ptr store_ contents. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00322">322</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a926c0efd4aefa9c441b803cedf3897b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename... A, typename Allocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;void&gt; <a class="el" href="classtlx_1_1Delegate.html">tlx::Delegate</a>&lt; R(A...), Allocator &gt;::store_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>shared_ptr used to contain a memory object containing the callable, like lambdas with closures, or our own wrappers. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00326">326</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>tlx/<a class="el" href="delegate_8hpp_source.html">delegate.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetlx.html">tlx</a></li><li class="navelem"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html">Delegate< R(A...), Allocator ></a></li>
    <li class="footer">Generated on Thu Mar 2 2017 17:21:34 for tlx by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.3.1 </li>
  </ul>
</div>
</body>
</html>
